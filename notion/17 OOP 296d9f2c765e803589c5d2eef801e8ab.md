# 17. OOP

Категория: Python Core
Статус: В процессе

Объектно-ориентированное программирование  (ООП) - это парадигма программирования, в которой программа строится как совокупность взаимодействующих объектов, каждый из которых является экземпляром определенного класса.

### Ключевые понятия

Класс - шаблон для создания объектов.

Объект (экземпляр) - конкретная реализация класса.

Атрибут - переменная, принадлежащая классу или объекту.

Метод - функция, определенная внутри класса.

![image.png](image%20108.png)

Принципы ООП

1. **Инкапсуляция (Encapsulation**) - сокрытие деталей реализации и предоставление контролируемого доступа к данным. 

Соглашение в Python (**name mangling**): 

1. __smth -  private
2. _smth - protected
3. smth - public

Метод __**setattr**__ запрещает создавать атрибуты объекта-экземпляра за пределами класса.

![image.png](image%20109.png)

![image.png](image%20110.png)

**Name Mangling** — автоматическое переименование атрибутов с `__` в `_ClassName__attribute`.

![image.png](image%20111.png)

### Зачем нужен name mangling?

**Основная цель:** избежать коллизий имён в наследовании.

1. Наследование (Inheritance) - создание новых классов на основе существующих, наследуя их свойства и методы.

![image.png](image%20112.png)

Дочерний класс можно создавать, используя параметры по умолчанию у родительского класса.

![image.png](image%20113.png)

1. Полиморфизм (Polymorphism) - способность объектов разных классов реагировать на одинаковые методы по-разному.

![image.png](image%20114.png)

1. Абстракция (Abstraction) - выделение существенных характеристик объекта и игнорирование несущественных.

![image.png](image%20115.png)

### Преимущества и недостатки ООП

Преимущества:

1. Повторное использование кода.
2. Модульность.
3. Гибкость и масштабируемость. 
4. Инкапсуляция данных.
5. Читаемость.

Недостатки:

1. Сложность проектирования.
2. Избыточность.
3. Производительность.
4. Рост сложности.

### Атрибуты класса и атрибуты экземпляра

![image.png](image%20116.png)

Виды наследования: 

1. Простое наследование
2. Наследование с переопределением методов
3. Расширение методов с использованием super()

![image.png](image%20117.png)

Виды полиморфизма:

1. Полиморфизм методов - один и тот же метод ведет себя по-разному для разных классов.
2. Перегрузка операторов - переопределение операторов для пользовательского класса.

![image.png](image%20118.png)

1. Утиная типизация - "Если что-то ходит как утка и крякает как утка, то это утка”.

![image.png](image%20119.png)

![image.png](image%20120.png)

### **MRO в Python (Method Resolution Order)**

MRO позволяет Python выяснить, из какого класса-предка нужно вызвать метод, если он не обнаружен непосредственно в классе-потомке.

В старых версиях  Python порядок разрешения методов был достаточно примитивным: поиск вёлся во всех родительских классах слева направо на максимальную глубину.

![image.png](image%20121.png)

![image.png](image%20122.png)

E,  B, A, D, C.

Но когда с версии Python 2.2 появился базовый класс object, появилась проблема   «ромбовидной структуры» («diamond diagram»). Если у класса есть несколько родителей, а у родителей есть общий предок, получаем ромб в дереве наследования, как видно на диаграмме.

Поскольку в Python 3 классы, для которых явно не указан предок, наследуются от `object`, любая ситуация множественного наследования в Python 3 является ромбовидной - в конечном итоге все классы-родители унаследованы от `object`.
Для поиска методов и полей в дереве родителей (MRO), Python использует алгоритм С3 **линеаризация**.

Совсем упрощенно C3 алгоритм MRO можно представить так:

- в список добавляются родители объекта
    - в конец списка добавляет список родителей этих родителей
    - и так далее
- если какой-то класс оказывается в списке дважды, то оставляется только последнее его вхождение.

Как результат, мы движемся по слоям, не обращаемся к классу-предку до того, как обратимся ко всем его потомкам, даже если потомков у этого предка несколько.

![image.png](image%20123.png)

Например, для класса `Platypus`, MRO будет `[Mammal, Bird, Dinosaur, Vertebrate]`. Вначале ищем в классах `Mammal`, `Bird`, `Dinosaur`, и, только если не найдет там, в `Vertebrate`.
Python 2 использовал другой алгоритм (`deep first`), MRO для Python 2 `[Mammal, Vertebrate, Bird, Dinosaur]` - если бы он не нашел метод в `Mammal`, далее стал бы искать выше по иерархии, в `Vertebrate`, а не в следующем по списку множественного наследования предке, `Bird`.

### Функция `super()`

Функция super() обеспечивает так называемое “кооперативное” наследование методов. Если во всех переопределенных методах использовать эту функцию, то она обеспечит вызов методов всех классов по алгоритму MRO.

`super()` это не класс-родитель, это объект, позволяющий вызвать следующий по

алгоритму MRO класс.

Название `super()` вводит в заблуждение - как показано ниже, `super()` вполне может найти метод не в родителе, а в “брате”, если тот следует далее по алгоритму MRO.

Это может привести к изменению поведения класса, если мы его добавляем в дерево наследования. Он начнет вызывать метод не родителя, как делал, когда не был добавлен в дерево множественного наследования, а другого класса, который переопределил метод родителя.

Вполне может быть, что нам этого и хотелось бы (скажем, мы добавили класс, который переопределяет что-то в `object`, и хотим чтобы это сказалось на всех классах в дереве наследования). Но в каких-то ситуациях это может оказаться неприятной и трудно обнаружимой проблемой.

![image.png](image%20124.png)

![image.png](image%20125.png)

![image.png](image%20126.png)

Если хоть один наследник нарушает принципы кооперативного наследования (не вызывает `super()`), то метод родителя вообще не будет вызван, хотя вроде бы мы имеем явный вызов этого родителя из другого наследника.

Одним из ограничений `super()` является то, что не получится выполнить операции ([binary operations](https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations), [subscriptions](https://docs.python.org/3/reference/expressions.html?highlight=slice#subscriptions) и т.д.) над возвращенным объектом, даже если эти операции реализованы в родителе вызывающего класса с помощью [“магических методов”](https://docs.python.org/3/library/operator.html).

Если выполнить операцию над экземпляром класса, то Python найдет нужный для выполнения операции “магический метод” в родителе (в примере ниже - `__getitem__` для индексирования с помощью оператора `[]`).

Но если попытаться выполнить операцию над объектом, возвращаемым `super()`, получим ошибку:

![image.png](image%20127.png)