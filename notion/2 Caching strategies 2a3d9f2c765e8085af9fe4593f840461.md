# 2. Caching strategies

Категория: Web & Networks
Статус: Готово

Кэширование - важнейший метод повышения скорости и производительности современных вычислений. Хранение часто используемых данных ближе к приложениям, сокращает время задержки, снижает нагрузку на серверную часть и уменьшает время отклика. 

Кэш - аппаратный или программный компонент, который хранит данные для будущих запросов. Сами данные - результат более раннего вычисления или копия данных, хранящаяся в другом месте. 

## Типы кэша

### Кэширование уровня приложения

![image.png](image%20553.png)

На уровне приложения кэширование подразумевает хранение данных в слое с быстрым доступом (обычно в оперативной памяти) внутри самого приложения или рядом с ним.

- Кэш в оперативной памяти - хранит часто используемые данные в оперативной памяти для быстрого доступа. Примеры: Redis (хранилище ключей-значений с TTL, pub/sub), Memcached (облегченное хранилище ключей-значений).
- Кэш объектов - хранит часто используемые объекты или структуры данных в памяти. Пример: [functools.lru_cache](https://www.google.com/search?client=opera&q=functools.lru_cache&sourceid=opera&ie=UTF-8&oe=UTF-8&mstk=AUtExfAjx0NaiNejYt66PhKIM-DjdBxeLJcMCT9mKfLVlbv5s3n2eoYlz5jBMBzZir1OjN2UOAzJFFRSEa9BxSR0CK_QVjIU193cfFqumkhMdmDS93Qu-fpxypYlDB3OIAg4F18FEIwnG0Q_7X-WBl6kOFcCeJNYLTJ0eVn7-ELrePR_t92Eb6HgoEHuLfIe-75E5wZUjKYEbuSRG8OD9mfIz_iwJTIOXVXtN2zU7segLJmDVgLMfevhCf5d0w62B1sf0a1V56QRNlyvmsVkAqtaGsMg&csui=3&ved=2ahUKEwjDvpHe1ZqRAxWuKRAIHUS3GIYQgK4QegQIARAC).
- Кэш сессий - хранит данные сеансов пользователя для сокращения количества обращений к базе данных. Примеры: Redis (хранилище сеансов для веб-приложений), Sticky Sessions (кэширование сеансов на стороне сервера).

### Кэширование на уровне БД

![image.png](image%20554.png)

Кэширование БД подразумевает сохранение копий результатов запросов к базе данных, строк или объектов в кэше (например, в хранилище в оперативной памяти, таком как Redis или Memcached, или даже во встроенном кэше базы данных). Когда приложению снова требуются эти данные, оно извлекает их из кэша, а не обращается к базе данных, что снижает задержку и нагрузку.

- Кэш запросов - хранит результат дорогих запросов к БД. Пример: MySQL Query Cache.
- Кэш на уровне строк - хранит определенные строки таблиц в памяти. Пример: Hibernate Second-Level Cache.

**Как работает**

1. Когда сессия запрашивает сущность, Hibernate сначала проверяет кэш первого уровня.
2. Если объект не найден там, проверяется кэш второго уровня.
3. Если объект найден во втором уровне, он загружается в кэш первого уровня и возвращается пользователю.
4. Если объект не найден ни в одном из кэшей, Hibernate извлекает его из базы данных, а затем сохраняет в обоих кэшах.
5. При изменении объекта в базе данных (например, при обновлении или удалении), он также автоматически обновляется или удаляется из второго уровня кэша.
- Кэш всех страниц - хранение всех страниц, сгенерированных БД.
- Сквозной для записи кэш - одновременно записывает данные и в кэш, и в БД. Обеспечивает согласованность, но увеличивает задержку записи.
- Кэш с обратной записью - данные сначала записываются в кэш, а затем асинхронно обновляются. Повышает производительность записи, но существует риск потери данных.

### Распределенное кэширование

![image.png](image%20555.png)

В распределенном кэше сам кэш представляет собой отдельную систему (например, Redis Cluster, Memcached, Hazelcast), которая работает на нескольких серверах, работающих вместе. Данные распределяются или реплицируются между этими узлами, что позволяет приложениям быстро получать к ним доступ даже при высокой нагрузке или в распределенных архитектурах, таких как микросервисы.

Кэш сети доставки контента (CDN): хранит статические ресурсы (CSS, JavaScript, изображения) на пограничных серверах, расположенных рядом с пользователями. Пример: Cloudflare, Akamai, AWS CloudFront.
Распределенное хранилище ключей и значений: хранит кэшированные данные на нескольких серверах. Примеры: Redis Cluster, Amazon ElastiCache, Apache Ignite.

### Веб-кэширование

![image.png](image%20556.png)

Веб—кэширование предполагает временное сохранение веб-данных в различных точках между пользователем и исходным сервером, таких как браузер, прокси-сервер или сеть доставки контента (CDN). 

Кэш браузера: хранит статические ресурсы в браузере пользователя. Пример: Заголовки для управления кэшем в HTTP.
Кэш прокси-сервера: Хранит HTTP-ответы между клиентом и сервером. Пример: Кэш Varnish, прокси-сервер Squid.
Кэш на стороне сервера: сохраняет сгенерированный HTML-код, чтобы избежать повторных вычислений. Пример: Кэш Nginx FastCGI.

### Кэширование на аппаратном уровне

![image.png](image%20557.png)

Кэширование на аппаратном уровне
Аппаратные кэши — это специализированные блоки памяти (обычно SRAM - статическая оперативная память), интегрированные в аппаратные компоненты. Они хранят копии данных, которые, по прогнозам системы, вскоре понадобятся, сокращая время, необходимое для извлечения этих данных из более медленной основной памяти (DRAM) или хранилища (например, жестких дисков, SSD-накопителей). Все дело в минимизации задержки и максимизации пропускной способности на самом низком уровне вычислительного стека.
Кэш процессора: хранит часто используемые инструкции в кэшах L1, L2, L3.
Дисковый кэш: Хранит часто используемые дисковые данные в оперативной памяти. Пример: Кэш страниц Linux, супервыборка Windows.

## Кэш стратегии

### Стратегии заполнения кэша

![image.png](image%20558.png)

- Без учета кэширования (Cache-Aside) - приложение сначала проверяет кэш. В случае сбоя оно извлекает данные из источника (например, базы данных) и вручную сохраняет их в кэше.

Плюсы: Простота, приложение контролирует, что кэшируется. 

Минусы: Риск устаревания данных; ошибки в кэше замедляют выполнение первых запросов. 

Пример использования: Кэширование на уровне приложения с помощью Redis.

- Сквозная запись (Write Through) -  данные записываются как в кэш, так и в резервное хранилище (например, в базу данных) одновременно.

Плюсы: Кэш остается совместимым с источником; нет устаревших данных. 

Минусы: Замедление записи из-за двойного обновления. 

Пример использования: Аппаратные кэши (например, CPU L1) или системы, требующие высокой согласованности.

- Обратная запись (Write-Behind) -cначала данные записываются в кэш, а затем асинхронно синхронизируются с резервным хранилищем.

Плюсы: Более быстрая запись; снижает нагрузку на исходный код. 

Минусы: Риск потери данных в случае сбоя кэширования перед синхронизацией. 

Варианты использования: Дисковые контроллеры, распределенные кэши с возможной согласованностью.

- Сквозное чтение (Read Through) - кэш сам извлекает данные из источника при пропуске, прозрачно для приложения.

Плюсы: Упрощает логику приложения; кэш обрабатывает загрузку. 

Минусы: Более тесная связь между кэшем и источником. 

Пример использования: Некоторые ORM или библиотеки кэширования (например, кэш второго уровня в режиме гибернации).

- Предварительная выборка (Pre-Fetching) - прогнозируемая загрузка данных в кэш до их запроса на основе шаблонов или местоположения.

Плюсы: Уменьшает количество пропусков; ускоряет доступ. 

Минусы: Пустая трата места, если прогнозы неверны. 

Пример использования: кэширование процессора (пространственная локализация), предварительная загрузка ресурсов CDN.

### Стратегии удаления кэша

![image.png](image%20559.png)

- Наименее недавно использованный (LRU- **Least Recently Used**): Удалить элемент, к которому в последнее время обращались реже всего.

Плюсы: Подходит для рабочих нагрузок с временной локализацией. 

Минусы: Накладные расходы на отслеживание порядка использования. 

Пример использования: Redis, кэширование процессора. 

- Последнее использование (MRU - **Most Recently Used**): Удаление последнего элемента, к которому был осуществлен доступ.

Плюсы: Полезно, когда вероятность повторного использования последних данных невелика. 

Минусы: На практике это встречается редко. 

Пример использования: Нишевые потоковые приложения. 

- Наименее часто используемые (LFU - **Least Frequently Used**): Исключите элемент, к которому обращаются реже всего.

Плюсы: Определяет приоритетность интенсивно используемых данных. 

Минусы: Требует отслеживания частоты использования; медленно адаптируется к меняющимся шаблонам. 

Пример использования: Веб-кэши со стабильными шаблонами доступа. 

- Первый вход, первый выход (FIFO - **First-In, First-Out** ): Удаление самого старого элемента независимо от его использования.

Плюсы: Простота реализации. 

Минусы: Игнорирует шаблоны доступа. 

Вариант использования: Базовые очереди или аппаратные буферы

- Срок годности (TTL - **Time-to-Live**): Срок годности данных истекает по истечении установленного времени, независимо от использования.

Плюсы: Предсказуемый срок годности; предотвращает устаревание. 

Минусы: Полезные данные могут быть удалены слишком рано. 

Пример использования: Веб-кэширование (HTTP Cache-Control), Redis с истечением срока действия. 

- Случайное удаление - **Random Eviction**: Удаление случайного объекта.

Плюсы: Очень просто; небольшие накладные расходы. 

Минусы: Непредсказуемая производительность. 

Вариант использования: Легкие системы или в качестве запасного варианта.

### Стратегии обеспечения согласованности кэширования

![image.png](image%20560.png)

- Запись-аннулирование - **Write-Invalidate**: когда данные обновляются в источнике, аннулируется (удаляется) соответствующая запись в кэше.

Плюсы: Обеспечивает свежесть данных при следующем чтении. 

Минусы: Следующее чтение приводит к ошибке. 

Вариант использования: Распределенные кэши (например, аннулирование ключа Redis при обновлении базы данных).

- Запись-обновление - **Write-Update**: обновление кэша немедленно при изменении источника.

Плюсы: Кэш остается свежим; после обновления не происходит сбоев. 

Минусы: Более высокие затраты на распространение обновлений. 

Пример использования: Согласованность кэша многоядерного процессора (например, протокол MESI).

- Возможная согласованность - **Eventual Consistency**: Кэширование - это стратегия, при которой данные в кэше и исходный источник данных (например, база данных) могут быть синхронизированы не сразу, но со временем они станут согласованными.

Плюсы: Хорошо масштабируется; допускает задержки. 

Минусы: Временная недоступность. 

Пример использования: Распределенные системы, такие как CDNS.

- Высокая согласованность - **Strong Consistency**: кэш и исходный код всегда синхронизированы (например, посредством сквозной записи или блокировки).

Плюсы: Нет устаревших данных. 

Минусы: Медленнее; менее масштабируемо. 

Пример использования: Критически важные системы (например, финансовые приложения).

### Стратегии размещения кэша

![image.png](image%20561.png)

- Локальное кэширование: Кэш находится на том же компьютере или в том же процессе, что и приложение.

Плюсы: Быстрый доступ; нет сети. 

Минусы: Ограниченный размер; не используется совместно. 

Варианты использования: кэширование на уровне процессора, хранилища в памяти на уровне приложения.

- Распределенное кэширование: кэш охватывает несколько узлов в кластере.

Плюсы: Масштабируемость; возможность совместного использования в разных приложениях. 

Минусы: Задержка в сети; сложность. 

Пример использования: кластер Redis, кэширование памяти в микросервисах.

- Пограничное кэширование: Кэш находится рядом с пользователем (например, на пограничных узлах CDN).

Плюсы: Уменьшает задержку для конечных пользователей. 

Минусы: Глобально его сложнее аннулировать. 

Пример использования: Веб-кэширование с помощью Cloudflare.

*P.S. Cloudflare — это **американская компания, предоставляющая услуги по оптимизации и защите веб-сайтов**. Она действует как посредник между сервером сайта и пользователями, используя свою глобальную сеть серверов для ускорения загрузки страниц и защиты от угроз, таких как DDoS-атаки.* 

### Компромиссы с кэшем

- Скорость и точность

Кэширование ускоряет скорость поиска данных за счет хранения часто используемых данных в памяти. Однако, кэшированные данные могут устареть, если не правильно признаны недействительными, что приведет к возможным неточностям. 

- Использование памяти и размер кэша

Кэширование данных занимает много памяти, и чем больше данных вы сохраняете, тем больше объем используемой памяти. При принятии решения о том, какой объем данных следует кэшировать, необходимо найти баланс между наличием достаточного количества данных в кэше для обеспечения быстрого реагирования и тем, чтобы не занимать слишком много памяти. 

- Свежесть данных в сравнении и продолжительность кэширования

Кэширование данных на длительный период может повысить производительность за счет уменьшения необходимости многократного извлечения данных. Однако чем дольше данные хранятся в кэше, тем больше вероятность того, что они устареют.

- Соотношение производительности при записи и производительности при чтении Скорость Чтения

Хотя кэширование может значительно повысить производительность при чтении, запись в кэш может стать более сложной задачей, особенно в системах, использующих стратегии сквозной или отложенной записи. Сквозная запись: каждый раз, когда данные записываются в кэш, они также записываются в базовое хранилище. Это может замедлить операции записи, но обеспечивает синхронизацию кэша и хранилища. Задержка записи: запись в кэш выполняется асинхронно, что повышает производительность записи, но существует риск несогласованности данных в случае сбоя записи в хранилище.

- Сложность аннулирования кэша

Аннулирование кэша при изменении данных имеет решающее значение для поддержания согласованности данных. Однако разработка эффективной стратегии аннулирования может быть сложной задачей, особенно в распределенных системах или сценариях с высокодинамичными данными. Эффективное аннулирование: гарантирует, что данные всегда актуальны, но логика аннулирования может быть сложной для реализации и может привести к дополнительным накладным расходам. Дополнительные затраты на устранение неполадок: при неправильной оптимизации такие механизмы устранения неполадок, как определение срока службы (TTL) или ручное устранение неполадок, могут привести к снижению производительности.

- Распределенное кэширование и Локальное кэширование

Распределенные кэши обеспечивают общий доступ к кэшу на нескольких серверах, повышая масштабируемость и согласованность между узлами, но они приводят к накладным расходам на сеть и потенциальной задержке. Локальные кэши работают быстрее, но ограничены областью действия узла. Распределенное кэширование: помогает обеспечить горизонтальное масштабирование и согласованность, но может привести к задержке в сети. Локальное кэширование: быстрее из-за отсутствия сетевых затрат, но кэш не распределяется между серверами, что ограничивает масштабируемость.

### Когда использовать кэш?

1. Высокая задержка или медленный доступ к данным

Загрузка данных из источника (например, базы данных, API, диска) занимает слишком много времени. Кэш сокращает время отклика за счет более быстрой обработки данных из оперативной памяти. Когда: задержка является узким местом, и пользователи замечают задержки.

1. Частый доступ к одним и тем же данным

Одни и те же данные запрашиваются повторно (временная локальность). Кэш позволяет избежать избыточных вычислений или извлечения. Когда: данные имеют высокую частоту чтения и низкую частоту изменения.

1. Дорогостоящие вычисления или запросы

Для создания данных требуются значительные ресурсы процессора, памяти или ввода-вывода. Кэш сохраняет результат один раз и повторно использует его вместо повторного вычисления. Когда: затраты на обработку превышают затраты на кэширование.

1. Временная доступность данных

Данные являются временными, но используются повторно в течение короткого периода времени. Кэш сохраняет данные в памяти, а не восстанавливает их или выполняет повторную выборку. Когда: данные имеют определенный срок службы и к ним часто обращаются.

1. Отказоустойчивость или автономная поддержка

Серверные системы могут выходить из строя или быть недоступны. Кэш обеспечивает резервное копирование для поддержания работоспособности системы. Когда: надежность или время безотказной работы имеют решающее значение.

### Технологии кэширования

1. Технологии кэширования в памяти
- Redis: Быстрое хранилище ключей и значений в памяти, часто используемое для обработки и кэширования данных в реальном времени. Поддерживает сохранение.
- Memcached: Простое и облегченное хранилище ключей и значений, предназначенное для высокопроизводительного кэширования.
2. Технологии кэширования баз данных
- Кэш запросов MySQL: Кэширует результаты запросов для снижения нагрузки на базу данных.
- Кэш PostgreSQL: Для кэширования часто используются сторонние расширения, такие как pg_bouncer или pgpool-II.
- Кэш базы данных Oracle: Предлагает кэширование базы данных в памяти для ускорения запросов на чтение.
3. Кэширование сети доставки контента (CDN)
- Cloudflare: CDN с возможностями кэширования для более быстрой доставки контента.
- AWS CloudFront: Кэширует содержимое в глобальных пограничных местоположениях.
4. Кэширование на уровне приложений
- Spring Cache - это абстракция в Spring Boot для обработки результатов кэширования.
- [ASP.NET](http://asp.net/) Кэш: встроенный механизм кэширования для .СЕТЕВЫЕ приложения.
5. Технологии распределенного кэширования
- Amazon ElastiCache: управляемый сервис Redis или Memcached.
- Кэш Azure для Redis: Управляемый кэш Redis для рабочих нагрузок Azure.
Облачное хранилище памяти Google: Полностью управляемый Redis и Memcached.
- NCache: платформа распределенного кэширования на базе .NET.
6. Кэширование на стороне браузера и клиента
- Кэш браузера: веб-страницы, изображения и другие ресурсы кэшируются локально.
- Сервисные службы: кэширование на стороне клиента для автономной работы.
- IndexedDB: Хранилище баз данных в браузерах для кэширования приложений, требующих больших объемов данных.
7. Гибридное и специализированное кэширование
- Apache Cassandra: база данных NoSQL со встроенными механизмами кэширования.
- Aerospike: Высокопроизводительная база данных реального времени со встроенным кэшированием.