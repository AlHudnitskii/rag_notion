# 2. Docker: Docker Best Practice

Категория: Docker & Kubernetes
Статус: Проверено

### Lightweight images

Легковесные Docker-образы (lightweight images) — это минималистичные шаблоны контейнеров, содержащие только необходимое для запуска приложения, что достигается за счет использования базовых образов с минимальной ОС (например, Alpine Linux).

**Ключевые принципы легковесных образов:**

1. **Минимальная база:** Использование базовых образов вроде Alpine Linux (очень маленький размер, всего 5 МБ), вместо полных дистрибутивов типа Ubuntu или CentOS.
2. **Слоистая структура (Layering):** Каждый шаг в `Dockerfile` создает новый слой. Docker кэширует эти слои, и если слои совпадают, они используются повторно, экономя место. Это основа легковеса, но важно не создавать лишние слои.
3. **Удаление "мусора":** После установки зависимостей (например, через `apt-get install`) необходимо удалять временные файлы и кэш, чтобы не «раздувать» слой (например, `rm -rf /var/lib/apt/lists/*`).
4. [**Multi-stage builds](https://www.google.com/search?q=Multi-stage+builds&client=opera&hs=04F&sca_esv=8f4c9c75088c6f0f&sxsrf=AE3TifOgUC9WsAcO7IaKM63stkZxNkmoUw%3A1765656183566&ei=d8Y9aZWtIvaswPAPoebp2AE&ved=2ahUKEwjZg4OnrruRAxWoLBAIHQkeMOYQgK4QegQIAxAF&uact=5&oq=Lightweight+images+%D0%B2+Docker+%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5&gs_lp=Egxnd3Mtd2l6LXNlcnAiMUxpZ2h0d2VpZ2h0IGltYWdlcyDQsiBEb2NrZXIg0L7QsdGK0Y_RgdC90LXQvdC40LUyBRAhGKABSNQdUI0CWOAbcAN4AZABAJgBe6ABqgmqAQQxMC4zuAEDyAEA-AEBmAIQoALhCcICChAAGLADGNYEGEfCAgYQABgWGB7CAggQABiABBiiBMICBRAAGO8FwgIJECEYoAEYChgqwgIHECEYoAEYCpgDAIgGAZAGCJIHBDEzLjOgB9krsgcEMTAuM7gH1wnCBwYwLjE0LjLIBx6ACAA&sclient=gws-wiz-serp&mstk=AUtExfAEnVrDFaV2xEX4FYkHUeiSDIktuJHGnSNaC9WQw2bYYVYe8qBPxjlxx-IqtL_rqJjUfiOcsPO99iI8Std-HbHSxyo_nob7SSC-INnrPbhY43YM29mlaqNlGXi6_I8-5zkhW6_RjC5CdY0cjBM9i9JTJ00vAXYPlwfoM5jdKtUFJLCBnQkOg6dIFS_Nlns0gOlilcF56Sbru3_B7i3hDtV-8xCGO--bSlWHgh4C7BXyFsQxIRHAnfeST_lpE9ABc9_YKcb4qWftlfthMtNDhUAfJ27eF1knn876PtyfkuETmA&csui=3) (Многоступенчатая сборка):** Использование одного образа для сборки (build stage) и другого, минимального, для финального запуска (runtime stage), перенося туда только готовый артефакт приложения.
5. **Объединение команд RUN:** Соединение нескольких команд в одну `RUN`, чтобы уменьшить количество слоев и избежать создания ненужных промежуточных файлов.
6. **Использование `.dockerignore`:** Исключение ненужных файлов (например, `.git`, `node_modules`, локальных логов) из контекста сборки, чтобы не копировать их в образ.

### Slim vs Alpine

Разница между образами Alpine и Slim в Docker в том, что Alpine — это минималистичный дистрибутив Linux (Alpine Linux) для экстремальной легкости, а Slim — это облегченная версия образа на основе Debian, но без лишних инструментов сборки и библиотек, предлагающая баланс между размером и привычным набором пакетов, что делает Slim более совместимым, а Alpine — самым маленьким, но требующим больше внимания к зависимостям. 

### Почему python-разработчики не любят alpline?

Часть python-зависимостей имеет установщик wheel, который alpline в себе не имеет, ввиду своей легкости, как итог, необходимо скачивать зависимости самому.

### Reducing number of layers

1. Слои: Docker строит образы на основе слоев, где каждый слой — это набор изменений (файлы, установленные пакеты). Инструкции `RUN`, `COPY`, `ADD` создают новые слои.
2. Кэширование: Слои кэшируются. Если слой не изменился, Docker использует кэш. Изменение в одном слое заставляет пересобирать все последующие слои, что замедляет сборку.
3. Уменьшение размера: Меньше слоев — меньше накладных расходов, быстрее сборка и меньше итоговый размер образа, так как избыточные данные не остаются в истории.

### Основные методы уменьшения слоев

- Объединение команд `RUN`: Вместо нескольких `RUN` для установки пакетов и очистки, объединяйте их в одну команду, используя `&&`.

![image.png](image%20388.png)

- Многоступенчатая сборка (Multi-Stage Builds): Используйте отдельный этап для сборки (с компиляторами, SDK) и финальный этап, куда копируются только нужные артефакты из первого, значительно уменьшая размер финального образа, как описано в статье.
- Очистка после установки: Удаляйте временные файлы, кэши менеджеров пакетов внутри того же слоя, где они были созданы.
- Минимизация `COPY`/`ADD`: Объединяйте копирование файлов, чтобы избежать лишних слоев, и используйте `.dockerignore`, чтобы не копировать ненужные файлы.
- Использование минимальных базовых образов: Например, `alpine`, `distroless`, чтобы начать с наименьшего возможного набора файлов.

### `.dockerignore`

`.dockerignore` — это специальный файл в корне проекта Docker, который работает как аналог `.gitignore` и указывает Docker-клиенту, какие файлы и папки **исключить** из контекста сборки образа. Это помогает ускорить сборку, уменьшить размер финального образа, повысить безопасность и избежать включения ненужных артефактов (например, `.git`, `node_modules`, временных файлов, логов), делая образ чище и эффективнее. 

### Синтаксис .dockerignore

- Каждая строка — шаблон: Указывает файл или папку для исключения.
- Комментарии: Строки, начинающиеся с `#`, игнорируются.
- Шаблоны (Wildcards):
    - * : Соответствует нулю или более символов (например, `*.log` игнорирует все файлы с расширением .log).
    - `?`: Соответствует одному символу.
    - `**`: Соответствует всему пути (например, `**/temp` игнорирует папку `temp` в любом месте).
- Исключения (Negation): `!` используется для включения файла, даже если он попал под более общий шаблон исключения (например, `!important.txt` после `.txt`).
- Пути:
    - `/`: Игнорирует файлы/папки только в корне контекста сборки (например, `/node_modules`).
    - Без `/`: Игнорирует в любом подкаталоге (например, `node_modules` игнорирует `node_modules` и `src/node_modules`).
    - `foo/`: Игнорирует папку `foo` и ее содержимое.
    - `foo`: Игнорирует файл или папку `foo`.

### Multi-stage build

Multi-stage build (многоэтапная сборка) в Docker работает, используя несколько инструкций `FROM` в одном `Dockerfile`, чтобы разделить процесс сборки и финальный образ: первый этап (например, `builder`) использует тяжелый образ с компиляторами и зависимостями для сборки приложения, а на финальном этапе с помощью `COPY --from=<stage_name>` копируются только готовые артефакты (бинарники) в легкий базовый образ, отбрасывая все лишнее, что делает финальный образ маленьким, безопасным и быстрым. 

### Как это работает?

1. **Этап сборки (Builder Stage):**
    - Первый этап (часто с меткой `AS builder`) использует образ, включающий все необходимое для сборки (SDK, компиляторы, dev-зависимости).
    - Здесь происходит копирование исходного кода и выполнение команд сборки (компиляция, сборка пакетов).
2. **Финальный этап (Runtime Stage):**
    - Второй этап начинается с минималистичного базового образа (например, `alpine`, `distroless`), который содержит только среду выполнения.
    - С помощью `COPY --from=builder` копируются только нужные файлы (скомпилированный бинарный файл) из первого этапа.
3. **Оптимизация:** В финальный образ не попадают инструменты сборки, исходники, временные файлы и лишние библиотеки, что значительно уменьшает размер, поверхность атаки и время запуска контейнера.

![image.png](image%20389.png)