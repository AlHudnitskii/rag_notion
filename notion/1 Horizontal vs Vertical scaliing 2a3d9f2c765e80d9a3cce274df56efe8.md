# 1. Horizontal vs Vertical scaliing

Категория: NoSQL & General theory
Статус: Готово

Масштабирование - процесс изменения ресурсов вычислительной системы для удовлетворения изменяющихся потребностей в обработке данных и предоставлении услуг.

Вертикальное масштабирование - увеличение производительности каждого компонента системы с целью повышения общей производительности.

Горизонтальное масштабирование - это процесс увеличения вычислительных мощностей системы за счет добавления новых серверов (узлов) в инфраструктуру. 

### **Вертикальное масштабирование**

![image.png](image%20672.png)

Такой подход зачастую оказывается простым и эффективным решением: не нужно перестраивать архитектуру, внедрять сложные механизмы распределения нагрузки или управлять целым парком серверов.

Однако за кажущейся простотой скрываются и определённые ограничения. Каждый сервер, каким бы мощным он ни был, имеет свой физический предел. В какой-то момент наращивать ресурсы становится либо невозможно, либо экономически нецелесообразно.

Пример:

- Добавление оперативной памяти или процессоров

### **Горизонтальное масштабирование**

Когда все меры по оптимизации исчерпаны — кеширование включено, индексы в базе данных настроены, а код и архитектура приложения оптимизированы — остаётся следующий шаг: горизонтальное масштабирования.

Горизонтальное масштабирование позволяет распределить нагрузку между несколькими серверами, добавляя новые узлы в систему, что обеспечивает более высокую устойчивость, производительность и позволяет системе обрабатывать больше запросов одновременно, снижая риск перегрузки и повышая доступность. 

Пример:

- Подключение нескольких новых серверов для работы с большим объемом данных

### LoadBalancer (Балансировщик нагрузки)

Этот компонент отвечает за распределение входящего трафика между несколькими серверами, что обеспечивает высокую доступность и оптимальную производительность системы.

![image.png](image%20673.png)

Алгоритмы распределения нагрузки балансировщика:

- **Круговое распределение (Round Robin):** Запросы отправляются по очереди на каждый сервер в кластере.
- **Наименьшая нагрузка (Least Connections):** Запрос направляется на сервер с наименьшим количеством активных соединений, что помогает избежать перегрузки.
- **По наилучшей производительности (IP Hashing):** Запросы распределяются на основе IP-адреса клиента, что позволяет сохранять сессии.
- **Случайное распределение (Random):** Запросы направляются на случайный сервер, что может быть полезно для равномерного распределения нагрузки.

При проектировании серверной архитектуры важно учитывать, как сервер обрабатывает состояния и информацию о пользователях. В этом контексте выделяют два основных типа серверов: **stateless** (бессостояние) и **stateful** (состояние).

- **Stateless** означает, что каждый запрос обрабатывается независимо от предыдущих. В таком случае всё будет работать эффективно и наша схема останется без изменений: нам не важно, на какой сервер направится запрос и как он будет обработан. Это позволяет легко масштабировать систему, добавляя или удаляя серверы по мере необходимости, без влияния на производительность и стабильность приложения.
- **Stateful**, на сайте есть пользователи, для сохранения состояния между запросами необходимо обеспечить постоянство сессий. Это позволит каждому пользователю продолжать взаимодействие с одним и тем же сервером, сохраняя данные о состоянии (например, информацию о корзине покупок или настройки профиля). Тут можно пойти 2 путями: сохранить состояние на сервисе (**sticky sessions**) или использовать общую сессию (**shared session)**.

### **Sticky sessions**

- **Использование Cookie**: Один из самых распространённых способов реализации постоянства сессий — это использование cookies. При первом запросе клиента лоадбалансер устанавливает cookie, который указывает, на какой сервер был направлен этот пользователь. В последующих запросах лоадбалансер будет проверять наличие этого cookie и направлять запросы на тот же сервер.
- **Использование IP-адреса**: это привязка сессий по IP-адресу клиента. Лоадбалансер будет отправлять все запросы от одного и того же IP на один и тот же сервер. Однако этот метод имеет свои недостатки, так как в случае использования NAT или прокси-серверов у нескольких пользователей может быть один и тот же IP-адрес.
- **Настройки Nginx**: если вы используете Nginx в качестве лоадбалансера, то вы можете включить sticky sessions, используя модуль **ngx_http_upstream_module**.

![image.png](image%20674.png)

### **Shared session**

Cостояние пользователей может храниться в памяти сервера. Однако это может привести к проблемам, если сервер выйдет из строя или будет заменён. В таких случаях необходимо предусмотреть механизмы резервного копирования состояния. Для повышения устойчивости можно использовать внешние системы хранения данных, такие как базы данных, **Redis** или **Memcached**. Это позволит хранить состояния пользователей в централизованном месте, доступном для всех серверов. Таким образом, независимо от того, на какой сервер будет направлен запрос, состояние пользователя всегда можно будет восстановить.

![image.png](image%20675.png)

### **Масштабирование Redis**

Redis не поддерживает автоматический шардинг из коробки, но можно разделить данные на несколько Redis-инстансов вручную. Вы делите ключи на разные серверы с помощью хэширования или другого метода распределения ключей по шардам. Например, с Redis Cluster можно распределять данные между узлами и автоматизировать их управление **Redis Cluster** — это встроенная функциональность Redis, которая позволяет автоматизировать распределение данных и поддерживать горизонтальное масштабирование. Redis Cluster создает группы узлов, распределяет данные между ними и автоматически выполняет репликацию для обеспечения отказоустойчивости. В случае выхода одного узла из строя, кластер перенаправит запросы к другим узлам.

### Масштабирование Postgres, Redis, Mongo

**PostgreSQL**

- **Вертикальное масштабирование:** Увеличение ресурсов (CPU, RAM) сервера, на котором работает PostgreSQL.
- **Репликация:** Создание копий базы данных для распределения нагрузки чтения (read replicas).
- **Секционирование:** Разделение больших таблиц на более мелкие и управляемые части (секции) по определенным критериям.
- **Шардирование:** Разбиение данных на независимые части (шарды) и распределение их по разным серверам.

**Redis**

- **Кластеризация:** Создание кластера Redis, который автоматически распределяет ключи между узлами для повышения доступности и масштабируемости.
- **Репликация:** Использование реплик для повышения доступности и производительности чтения.

**MongoDB**

- **Шардирование:** Основной метод горизонтального масштабирования, при котором данные распределяются по нескольким серверам (шардам).
- **Репликация:** Использование реплика-сетов для повышения отказоустойчивости и распределения нагрузки чтения.
- **Вертикальное масштабирование:** Увеличение ресурсов сервера, на котором работает MongoDB.