# 7. SQLAlchemy 1.x & 2.x

Категория: Frameworks & Libraries
Статус: В процессе

SQLAlchemy (latest 2.0.44) — это наиболее популярная ORM (Object-Relational Mapping) библиотека для Python, которая позволяет работать с базами данных через объекты Python вместо написания чистого SQL. Состоит из двух основных частей:

- **Core** — низкоуровневый SQL Toolkit для работы с базами данных
- **ORM** — высокоуровневый слой объектно-реляционного отображения поддерживающий ORM,

![image.png](image%20467.png)

### Особенности SQLAlchemy

1. Session и Engine

**Engine** — точка входа в базу данных, управляет connection pool:

![image.png](image%20468.png)

![image.png](image%20469.png)

**Session** — контекст для работы с БД, управляет транзакциями и Unit of Work:

![image.png](image%20470.png)

1. Relationships 
- **One-to-Many**

![image.png](image%20471.png)

- **One-to-One**

![image.png](image%20472.png)

- **Many-to-Many**

![image.png](image%20473.png)

1. N + 1 problem

![image.png](image%20474.png)

**Стратегии загрузки:**

- `lazy='select'` — по умолчанию, загружает при обращении
- `selectinload()` — отдельный SELECT для связанных данных
- `joinedload()` — JOIN в одном запросе
- `subqueryload()` — через подзапрос
1. SQLAlchemy обычно используется с Alembic для миграций:

![image.png](image%20475.png)

1. Async SQLAlchemy 2.x

![image.png](image%20476.png)

### QA

**1. В чем разница между `flush()` и `commit()`?**

- `flush()` — синхронизирует состояние сессии с БД (сбрасывает буфер), но не фиксирует изменения и не завершает транзакцию
- `commit()` — делает flush + фиксирует транзакцию

**2. Что такое Unit of Work?**
Паттерн, который отслеживает изменения объектов и автоматически генерирует SQL для сохранения изменений.

**3. Как избежать N+1 проблемы?**
Использовать eager loading через `selectinload()`, `joinedload()` или `subqueryload()`.

**4. Зачем нужен `scoped_session`?**
Для thread-safe работы с сессиями, каждый поток получает свою сессию.

**5. Чем отличается `session.query()` от `select()`?**

- `session.query()` — legacy API из 1.x,
- `select()` — современный подход 2.x с лучшей типизацией.

### SQLAlchemy 1.x and SQLAlchemy 2.x

### Основные причины перехода:

1. **Устаревший API** - `session.query()` был создан до появления современных Python практик
2. **Плохая типизация** - невозможность нормально работать с mypy/типизацией
3. **Отсутствие async** - asyncio стал стандартом, но в 1.x был только сторонний asyncpg
4. **Неявное поведение** - много "магии", которая приводила к багам
5. **Проблемы производительности** - некоторые паттерны были неоптимальными

### Ключевые изменения в 2.x
1. Новый стиль запросов - `select()` вместо `query()`

![image.png](image%20477.png)

![image.png](image%20478.png)

**2. Typed Mappings - Строгая типизация**

![image.png](image%20479.png)

![image.png](image%20480.png)

1. Новый DeclarativeBase

![image.png](image%20481.png)

![image.png](image%20482.png)

1. Native Async Support

В первой версии Алхимии

![image.png](image%20483.png)

Во второй версии Алхимии

![image.png](image%20484.png)

![image.png](image%20485.png)

**Поддерживаемые async драйверы:**

- `asyncpg` для PostgreSQL
- `aiomysql` для MySQL
- `aiosqlite` для SQLite
1. relationship.backref and relationship.back_populates

`backref` и `back_populates` — это параметры в функции `relationship()` SQLAlchemy, которые позволяют установить *двунаправленную* связь между двумя моделями

Использование back_populates требует, чтобы атрибуты отношений были явно определены в обоих классах.

![image.png](image%20486.png)

`backref` — это сокращение, которое **автоматически** создает атрибут отношения на связанном классе без необходимости явного его определения.

![image.png](image%20487.png)

![image.png](image%20488.png)

### Интереcные особенности SQLAlchemy 2.x

1.  Mapped[]

**SQLAlchemy анализирует аннотации во время выполнения!** Она использует `__annotations__` для автоматической настройки колонок.

![image.png](image%20489.png)

1. Write-Only Relationships

Проблема в 1.x:

![image.png](image%20490.png)

Решение в 2.x — WriteOnlyMapped:

![image.png](image%20491.png)

1.  Polymorphic Identity — наследование таблиц

![image.png](image%20492.png)

1. Статический анализ с mypy плагином

![image.png](image%20493.png)

1. Active Record and Data Mapper

**Active Record** — это шаблон проектирования, используемый в Django ORM, где класс модели отвечает не только за данные, но и за их сохранение в базе данных. **Data Mapper** — это другой шаблон, используемый в SQLAlchemy, который разделяет объекты Python от их представления в базе данных, используя отдельный слой для маппинга данных. 

**Active Record (Django ORM)**

- **Принцип:** Вся логика, связанная с данными (включая сохранение, обновление и удаление), находится внутри самого объекта модели.
- **Пример:** Вы создаете объект `MyModel`, изменяете его атрибуты, а затем вызываете метод `.save()` этого же объекта для сохранения изменений в базе данных.
- **Плюсы:** Прост в использовании и понимании, особенно для начинающих, так как логика работы с данными тесно связана с объектами.
- **Минусы:** Нарушает принцип единственной ответственности (SOLID), поскольку класс модели отвечает одновременно и за представление данных, и за их хранение.

**Data Mapper (SQLAlchemy)**

- **Принцип:** Существует четкое разделение между объектами данных (моделями) и объектами, отвечающими за их постоянное хранение (мапперами). Это позволяет отделять логику представления данных от логики их персистентности.
- **Пример:** Вы создаете объект класса, работаете с его полями. Для сохранения объект передается в маппер (или сессию), который затем управляет сохранением данных в базе. SQLAlchemy использует различные способы, включая "Mapped" и "mapped_column" для определения связей между объектами Python и таблицами базы данных.
- **Плюсы:** Более гибкий и масштабируемый подход. Лучше соответствует принципу единственной ответственности.
- **Минусы:** Может быть сложнее для понимания и может потребовать написания более объемного кода, чем в случае с Active Record.