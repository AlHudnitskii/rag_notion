# 2. Multiprocessing

Категория: Python Async & Related
Статус: В процессе

Можно вместо потоков создать несколько конкурентных процессов, это называется *многопроцессорностью*. В таком случае родительский процесс создает один или более дочерних процессов, которыми управляет, а затем распределяет между ними работу.

В Python для этой цели имеется модуль multiprocessing. Его API похож на API модуля threading. Сначала создается процесс, при этом передается функция target. Затем вызывается метод start, чтобы начать выполнение процесса, и в конце – метод join, чтобы дождаться его завершения.

![image.png](image%20235.png)

**Главное отличие от threading:** каждый процесс имеет свой интерпретатор Python и своё адресное пространство памяти, поэтому **нет GIL**. Это позволяет реально использовать все ядра CPU.

### Когда использовать multiprocessing:

- **CPU-bound задачи**: вычисления, обработка данных, ML/AI
- Необходимость реального параллелизма
- Изоляция (сбой в одном процессе не роняет другие)

### Когда НЕ использовать:

- I/O-bound задачи (лучше asyncio или threading)
- Большой overhead на создание процессов
- Нужен частый обмен данными между процессами

**Основные способы создания процессов**
1. Process class из модуля multiprocessing

![image.png](image%20236.png)

1. Pool 

![image.png](image%20237.png)

1. ProcessPoolExecutor (concurrent.futures)

![image.png](image%20238.png)

Межпроцессорное взаимодействие (IPC  — Inter-Process Communication)

1. **Queue из модуля multiprocessing — потокобезопасная очередь**

![image.png](image%20239.png)

Еще пример использование Queue

![image.png](image%20240.png)

![image.png](image%20241.png)

1. **Pipe — двусторонний канал**

![image.png](image%20242.png)

1. **Manager - для разделяемых объектов**

![image.png](image%20243.png)

1. **Value and Array - разделяемая память (быстрее, но ограничена)**

![image.png](image%20244.png)

Важные концепции: 

1. Методы старта процессов

![image.png](image%20245.png)

1. Daemon процессы

![image.png](image%20246.png)

1. **Пулы с разными стратегиями:**
- `map()` — блокирующий, все сразу
- `imap()` — итератор, lazy
- `imap_unordered()` — результаты в порядке завершения
- `apply_async()` — асинхронное выполнение одной задачи

### Shared memory

**Shared Memory (разделяемая память)** — это область памяти, к которой могут обращаться несколько процессов одновременно.

![image.png](image%20247.png)

![image.png](image%20248.png)

![image.png](image%20249.png)

### Ключевые концепции:

1. **Разделяемая память** — физическая RAM, доступная нескольким процессам
2. **Нет копирования** — данные не дублируются между процессами
3. **Прямой доступ** — быстрее чем IPC через Queue/Pipe
4. **Опасность** — нужна синхронизация (race conditions)

Способы достижения shared memory

1. Использования value and array

![image.png](image%20250.png)

Доступные типы данных

![image.png](image%20251.png)

1.  SharedMemory (современный, Python 3.8+)

![image.png](image%20252.png)

![image.png](image%20253.png)

1. Использование Manager

![image.png](image%20254.png)

### Синхронизация Shared Memory

**Проблема: Race Conditions**

Решение: 

1. Lock из модуля multiprocessing
2. Встроенный Lock в Value/Array
3. RWLock паттерн для SharedMemory

![image.png](image%20255.png)

## Pros and Cons of Processes

### Преимущества (Pros):

1. Истинный параллелизм (нет GIL)

2. Изоляция и стабильность:

- Сбой в одном процессе не роняет другие
- Нет race conditions на уровне памяти (по умолчанию)
- Каждый процесс имеет свой интерпретатор

3. Безопасность: процессы не могут случайно перезаписать данные друг друга, в отличие от потоков с общей памятью

**4. Лучше для CPU-bound:**

- Обработка изображений/видео
- Научные вычисления
- Криптография
- ML inference

5. Простая масштабируемость:

![image.png](image%20256.png)

### Недостатки (Cons):

**1. Overhead на создание:**

![image.png](image%20257.png)

2. Высокое потребление памяти: каждый процесс - копия интерпретатора и всех данных

**3. Overhead на IPC (Inter-Process Communication)**

![image.png](image%20258.png)

1. Не подходит для I/O-bound:

![image.png](image%20259.png)

Практические советы:

1. Выбор между threading, multiprocessing, asyncio:

![image.png](image%20260.png)

1. Используйте Pool вместо создания отдельных Process
2. Используйте SharedMemory для больших данных