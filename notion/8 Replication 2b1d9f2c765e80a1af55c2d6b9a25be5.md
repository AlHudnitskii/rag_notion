# 8.  Replication

Категория: NoSQL & General theory
Статус: Готово

Репликация — это процесс копирования данных с одного узла базы данных на другие узлы, чтобы обеспечить:

- отказоустойчивость (HA)
- горизонтальное масштабирование чтения
- быстрые failover
- геораспределённость данных
- возможность онлайн-аналитики без нагрузки на primary

В PostgreSQL есть два ключевых направления:

- **Physical (streaming) replication**
- **Logical replication**

### Physical (Streaming) Replication

**Физическая потоковая репликация** — это копирование данных на уровне *файлов базы* и *сырых WAL-блоков*.

1. Primary записывает все изменения в WAL (Write-Ahead Log)
2. Standby получает WAL через streaming-protocol (Реплика подключается как “реплика-процесс” и запрашивает новые WAL-сегменты).
3. Standby применяет WAL byte-by-byte.

Это делает standby *бит-в-бит идентичным* мастеру.

Что реплицируется?

Все **файлы базы** полностью:

- таблицы
- индексы
- sequences
- системный каталог
- служебные файлы
- FSM/VM карты (Free Space Map and Visibility Map)
- транзакционные логи

Ограничения на реплику:

- На реплику нельзя писать, только SELECT
- Фильтрации данных нет → Реплика ПОЛНАЯ копия istance
- Реплицировать отдельные таблицы нельзя -  Только весь кластер как есть
- Реплика имеет ту же major-версию Postrges

### Logical Replication

**Logical replication = репликация на уровне строк/операций (row-level)** и **не копирует файлы базы**.

Использует **logical decoding** WAL-журнала.

1. WAL декорируется на уровне изменения строк

![image.png](image%20731.png)

1. Primary публикует изменения (PUBLICATION)

![image.png](image%20732.png)

1. Replica подписывается на публикацию (SUBSCRIPTION)

![image.png](image%20733.png)

1. Replica применяет изменения как обычные SQL-операции

![image.png](image%20734.png)

Ограничения на реплику:

- работает на уровне **таблиц**
- Реплика может иметь свои таблицы

В отличие от physical — **полноценная writable БД**.

- Конфликты возможны

Если replica сама пишет в таблицу, на которую подписана,

могут быть: update conflicts, insert conflicts и missing PK (логическая репликация требует PK).

- не реплицируются: DDL (ALTER TABLE), sequences (до версии 16 — частично кастыльно), большие объёмы данных эффективно (только начальный copy)

![image.png](image%20735.png)

### Master-slave & Master-master

«Master-slave» и «Master-master» — это **две разные модели репликации (копирования) данных, часто используемые в базах данных**. В **«Master-slave»** есть один главный сервер (Master), который обрабатывает все запросы на запись, а другие серверы (Slaves) только читают данные и получают их копии с Master'а. В **«Master-master»** все серверы могут принимать запросы на запись, а изменения синхронизируются между ними, что повышает отказоустойчивость и доступность. 

### Master–Slave Replication (Postrges)

Есть **один мастер (primary)**, куда идут все записи.

Есть **одна или много реплик (standby)**, которые получают изменения от мастера и применяют их.

Если master падает, то один из slave заменяет его, становясь master. 

### Плюсы Master–Slave

- Увеличение READ-пропускной способности
- Почти мгновенные бэкапы
- Уменьшение нагрузки на primary
- Высокая доступность
- Простая настройка

### Минусы Master–Slave

- Все записи идут на один сервер → bottleneck
- Реплике нельзя писать
- Потенциальная потеря данных при async-репликации
- Тяжелее решать конфликты логически, потому что реплика идентична мастеру

### Master–Master (или Multi-Master) Replication

**Multi-master** — это когда *несколько* узлов могут выполнять *записи*, и изменения реплицируются между ними.

![image.png](image%20736.png)

В Postrges нет master-master “из коробки”

Для multi-master используются внешние системы:

- **BDR (Bi-Directional Replication)**
- **pglogical**
- **Bucardo**
- **Citus MX**
- **Logical Replication + conflict management**

Эти инструменты используют **logical replication**.

### Механизм работы multi-master

1. Каждый мастер публикует изменения

Через logical decoding данные превращаются в реплицируемые сообщения.

2. Каждый мастер подписывается на других

[https://www.notion.so](https://www.notion.so)

3. Нужен механизм разрешения конфликтов

Потому что два мастера могут редактировать одну строку.

### Конфликты Master-Master

1. Update–update conflict

Оба мастера изменили одну строку:

![image.png](image%20737.png)

Чаще всего last-read-wins 

1. Insert–insert conflict

Обе ноды вставили запись с одинаковым PK.

Обычно решают:

- UUID primary keys
- Sequence ranges:
    
    master A: 1–1B
    
    master B: 1B–2B
    
- Conflict resolver: pick one insert
1. Delete–update conflict

Одна нода удаляет запись, другая обновляет.

Правила:

- DELETE wins (чаще всего)
- или UPDATE resurrects the row (реже)

### Плюсы Master–Master

- Геораспределённые записи (multi-region writes)
- Нет одного bottleneck для write
- Можно писать ближе к пользователю → низкая latency
- Прекрасно для оффлайновых систем (точки продаж)
    
    ### Минусы Master–Master
    
- Сложность
- Конфликты
- Сложно вертикально масштабировать (все узлы должны быть мощными)
- Строгая необходимость логических PK (UUID)
- Порядок транзакций не глобальный (нет global commit order)
- Может появиться data drift, если неправильно настроить

![image.png](image%20738.png)