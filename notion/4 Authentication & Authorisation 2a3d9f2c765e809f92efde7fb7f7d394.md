# 4. Authentication & Authorisation

Категория: Web & Networks
Статус: Готово

Идентификация, аутентификация и авторизация — это три последовательных этапа обеспечения безопасности при доступе к системе: **идентификация** (кто вы) — когда пользователь заявляет о себе (логин); **аутентификация** (вы ли это) — когда система проверяет подлинность личности (пароль, биометрия); и **авторизация** (что вам можно) — когда система определяет, какие права доступа вы имеете. 

**Аутентификация** — это процесс проверки личности пользователя. Она подтверждает, что человек действительно тот, за кого себя выдает, используя учетные данные вроде паролей или биометрических данных (например, отпечатки пальцев).

**Авторизация** — это процесс определения прав доступа пользователя к системным ресурсам. Она решает, какие действия пользователь может выполнять, например, создавать, читать, изменять или удалять файлы.

**Ключевые моменты:**

- Аутентификация обычно происходит перед авторизацией — система сначала должна узнать пользователя, прежде чем предоставить ему доступ
- Оба процесса применяются не только к людям, но и к устройствам, автоматизированным системам и веб-приложениям
- Атаки на основе идентификации составляют 30% всех кибератак [ibm](https://www.ibm.com/think/topics/authentication-vs-authorization)
- Надежная аутентификация затрудняет взлом учетных записей, а строгая авторизация ограничивает ущерб в случае компрометации

### Basic Authentication

Basic Authentication (Базовая аутентификация) — это **простой протокол для проверки подлинности пользователя, при котором логин и пароль передаются в каждом запросе в закодированном виде ([Base64](https://www.google.com/search?q=Base64&client=opera&hs=C4I&sca_esv=f79b0fb78531cc6c&sxsrf=AE3TifMuKmxP2A5tHQzt6lFj7p_k-PYWPw%3A1764873265203&ei=MdQxaZKZDLmTwPAPrt3LmAw&ved=2ahUKEwjztcKhyaSRAxU2ExAIHTojHtAQgK4QegQIARAC&uact=5&oq=%D0%A7%D1%82%D0%BE+%D1%8D%D1%82%D0%BE+%D0%B2%D0%BE%D0%BE%D0%B1%D1%89%D0%B5+%D0%B7%D0%BD%D0%B0%D1%87%D0%B8%D1%82%3F+Basic+Authentication&gs_lp=Egxnd3Mtd2l6LXNlcnAiPdCn0YLQviDRjdGC0L4g0LLQvtC-0LHRidC1INC30L3QsNGH0LjRgj8gQmFzaWMgQXV0aGVudGljYXRpb24yBhAAGBYYHjIFEAAY7wVItQNQAFi5AnAAeAGQAQCYAdIBoAGZA6oBBTAuMS4xuAEDyAEA-AEB-AECmAICoAKiA5gDAJIHAzItMqAH6gOyBwMyLTK4B6IDwgcDMC4yyAcE&sclient=gws-wiz-serp&mstk=AUtExfA3C_2xNy_99YFY9P6pb7rv3SF7meFDByGEhEUKDSHsxTuHXk5aw7K2TaxOcEVjdsZahMfbdNTWNtuusk6K1cZ7G7mApUok25cSH8F5YjIC_953ruWeD5sy4zpQ7NgW2V3V6wWQbxz94BsCvCsjAQCmKwCjON1a6yAZjL4PIHDd8DAj953SEqaOB9sRI87ImrPeh5xzjgY2DiLUD7_lyLEg0k9jHOaq5L2iXCfX8p3SkhXNJOzaiH_wsKkXz1RlXvTJ9YMTd0Mbpeyi8RHb5oDM&csui=3)) для доступа к защищенным ресурсам**. Это один из самых старых и простых методов авторизации, который часто используется для защиты сайтов и API.

**Как это работает**

- При попытке получить доступ к защищенному ресурсу, браузер пользователя запрашивает имя пользователя и пароль.
- Логин и пароль объединяются в одну строку через двоеточие (например, `user:password`).
- Эта строка кодируется с помощью алгоритма Base64 (например, `dXNlcjpwYXNzd29yZAo=`).
- Кодированная строка отправляется на сервер в заголовке `Authorization` HTTP-запроса.
- Сервер декодирует полученные данные и сверяет их с учетными записями. Если они совпадают, доступ предоставляется.

**Важные моменты**

- **Простота:** Метод очень прост в реализации, но менее безопасен, так как данные передаются в каждом запросе.
- **Безопасность:** Используйте этот метод только через **HTTPS** (защищенное соединение), чтобы предотвратить перехват логина и пароля. Без HTTPS данные отправляются в закодированном, но легко декодируемом виде.

![image.png](image%20572.png)

1. Когда браузер впервые запрашивает сервер, сервер пытается проверить наличие заголовка  **`Authorization`**  ****в запросе. Поскольку это первый запрос, заголовок авторизации в запросе не найден. Таким образом, сервер отвечает кодом  **`401 Unauthorized`** , а также отправляет заголовок **`WWW-Authenticate`**  со значением, равным  **`Basic`**, который сообщает браузеру, что ему необходимо запустить процесс базовой аутентификации.
2. После получения ответа от сервера браузер заметит заголовок  **`WWW-Authenticate`** и отобразит всплывающее окно проверки подлинности.
3. После того, как пользователь введет учетные данные через это всплывающее окно для проверки подлинности, браузер автоматически закодирует учетные данные, используя кодировку  **`base64`**, и отправит их в заголовке **`Authorization`** того же запроса.
4. После получения запроса сервер расшифрует и проверит учетные данные. Если учетные данные действительны, сервер отправит ответ клиенту.

### Token authentication

Аутентификация токена — это **протокол безопасности, при котором система выдаёт пользователю временный зашифрованный «токен» вместо постоянного пароля после успешного входа**. Этот токен затем используется для доступа к защищённым ресурсам, что делает этот метод более надёжным и удобным, чем многократный ввод логина и пароля.

**Как это работает**

- **Первый вход:** Пользователь отправляет свои учётные данные (логин и пароль) на сервер.
- **Проверка:** Сервер проверяет их и, если они верны, генерирует уникальный, зашифрованный токен.
- **Отправка токена:** Сервер отправляет этот токен обратно клиентскому приложению (например, браузеру).
- **Последующие запросы:** При последующих запросах к защищённым ресурсам приложение отправляет этот токен на сервер вместо логина и пароля.
- **Авторизация:** Сервер проверяет токен и, если он действителен, предоставляет доступ к ресурсу.

**Ключевые особенности**

- **Повышенная безопасность:** Использование токенов, особенно в сочетании с паролем ([двухфакторная аутентификация](https://www.google.com/search?client=opera&q=%D0%B4%D0%B2%D1%83%D1%85%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%BD%D0%B0%D1%8F+%D0%B0%D1%83%D1%82%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F&sourceid=opera&ie=UTF-8&oe=UTF-8&mstk=AUtExfCb-qb4peMUZVXa_lyqQtXVuEqwak2xnRfKtuykyN-vGvYzn4IqXaXt7rK_ngJmFEptZKudgy-GYoRW9cxSB0UW-Y76QsLsQRnMRcoCwecJMSe5WaXst_POmJh8d7zxTfOCthzF0mu1QK80-1_r8PCDCK8ohy9Clgj2Hkzv1DpZwFOmzzWZn4osdGbO81T3eJoPPM7Bw0GXe_VWv147JZBcIEyClvaVU743C1nxH-s0jYvDV666BV-1A5xEmg9ddd5sPWGFBqwizB848rnhs7ZM&csui=3&ved=2ahUKEwiXxfGQyqSRAxXSGhAIHeF3LT8QgK4QegQIBRAB)), обеспечивает дополнительный уровень защиты от взлома.
- **Временное действие:** Токены имеют ограниченный срок действия, что снижает риск утечки информации в случае компрометации.
- **Удобство:** Пользователю не нужно вводить пароль при каждом запросе после первоначальной аутентификации.
- **Гибкость:** Используется в различных системах, например, при доступе к API, благодаря стандартизированным форматам, таким как [JSON Web Tokens (JWT)](https://www.google.com/search?client=opera&q=JSON+Web+Tokens+%28JWT%29&sourceid=opera&ie=UTF-8&oe=UTF-8&mstk=AUtExfCb-qb4peMUZVXa_lyqQtXVuEqwak2xnRfKtuykyN-vGvYzn4IqXaXt7rK_ngJmFEptZKudgy-GYoRW9cxSB0UW-Y76QsLsQRnMRcoCwecJMSe5WaXst_POmJh8d7zxTfOCthzF0mu1QK80-1_r8PCDCK8ohy9Clgj2Hkzv1DpZwFOmzzWZn4osdGbO81T3eJoPPM7Bw0GXe_VWv147JZBcIEyClvaVU743C1nxH-s0jYvDV666BV-1A5xEmg9ddd5sPWGFBqwizB848rnhs7ZM&csui=3&ved=2ahUKEwiXxfGQyqSRAxXSGhAIHeF3LT8QgK4QegQIBRAF).
Access-токены и refresh-токены — **это два типа токенов, используемых для аутентификации и авторизации в современных приложениях, где access-токен используется для доступа к ресурсам, а refresh-токен — для получения нового access-токена после его истечения**. Access-токен имеет короткий срок жизни, а refresh-токен — длительный, что повышает безопасность и удобство для пользователя.

![image.png](image%20573.png)

![image.png](image%20574.png)

Access-токены и refresh-токены — **это два типа токенов, используемых для аутентификации и авторизации в современных приложениях, где access-токен используется для доступа к ресурсам, а refresh-токен — для получения нового access-токена после его истечения**. Access-токен имеет короткий срок жизни, а refresh-токен — длительный, что повышает безопасность и удобство для пользователя. 

### Cookie-Based Authentication

Аутентификация на основе файлов cookie (cookie-based authentication) — это **метод идентификации пользователей в веб-приложениях, при котором сервер отправляет в браузер уникальный идентификатор в виде файла cookie после успешного входа**. Этот cookie сохраняется в браузере и отправляется обратно серверу при каждом последующем запросе, позволяя серверу узнать пользователя и поддерживать его авторизованный статус без повторной аутентификации на каждой странице. 

**Как это работает**

1. **Вход пользователя:** Пользователь вводит свои учетные данные (логин и пароль).
2. **Проверка на сервере:** Сервер проверяет подлинность учетных данных.
3. **Создание cookie:** Если данные верны, сервер создает уникальный идентификатор сессии или токен.
4. **Отправка cookie:** Сервер отправляет этот идентификатор в браузер пользователя в виде файла cookie.
5. **Сохранение в браузере:** Браузер сохраняет этот cookie.
6. **Последующие запросы:** При каждом новом запросе к сайту браузер автоматически отправляет сохраненный cookie обратно на сервер.
7. **Идентификация пользователя:** Сервер получает cookie, распознает пользователя и предоставляет ему доступ к защищенным данным, не требуя повторного входа.

**Ключевые особенности**

- **Состояние на стороне сервера:** Это аутентификация «с состоянием», так как серверу необходимо хранить информацию обо всех активных сессиях пользователей, чтобы их распознавать.
- **Удобство для пользователя:** Пользователю не нужно каждый раз вводить логин и пароль, что делает навигацию более плавной.
- **Безопасность:** Хотя это удобный метод, он также имеет уязвимости. Если злоумышленник получит доступ к cookie, он может выдать себя за пользователя. Поэтому важна защита этих файлов cookie.

Токены (JWT) и сессии (Cookie)

Аутентификация на основе сеансов (session-based) и токенов (token-based) — это два разных способа управления доступом пользователя к веб-приложениям после входа в систему. Сеансы требуют постоянного обращения к серверу для проверки, тогда как токены — это самодостаточные ключи, передаваемые клиентом при каждом запросе для проверки подлинности, что делает их более подходящими для масштабируемых и кросс-сервисных архитектур. 

**Аутентификация на основе сеансов (Session-based)**

- **Как работает:** После входа пользователя сервер создает уникальный идентификатор сеанса (session ID) и сохраняет его на стороне сервера, обычно в базе данных или кэше. Клиенту возвращается только этот идентификатор (обычно в виде cookie). Каждый последующий запрос пользователя содержит этот cookie, и сервер использует его для поиска соответствующей информации о сеансе, проверяя тем самым его подлинность.
- **Преимущества:**
    - **Возможность отмены:** Сервер может мгновенно аннулировать сеанс в любой момент, например, при выходе пользователя или обнаружении подозрительной активности.
    - **Меньшая нагрузка на сеть:** Каждый запрос содержит только маленький идентификатор сеанса, а не всю информацию о пользователе.
- **Недостатки:**
    - **Требуется хранилище на сервере:** Серверу необходима база данных или другое хранилище для хранения всех активных сеансов, что может создавать проблемы с масштабируемостью.
    - **Сложность для распределенных систем:** В распределенной архитектуре, где пользователь может быть обработан любым из множества серверов, требуется централизованное хранилище сеансов, чтобы все серверы могли получить доступ к одной и той же информации.

**Аутентификация на основе токенов (Token-based)**

- **Как работает:** После успешного входа пользователя сервер генерирует токен (например, [JWT](https://www.google.com/search?q=JWT&client=opera&hs=cHJ&sca_esv=f79b0fb78531cc6c&sxsrf=AE3TifO82ArsmkHH96YI8HRHchlN2SL68A%3A1764874097683&ei=cdcxaaXAKeKnwPAPquvAoQo&ved=2ahUKEwjRlOSkzaSRAxVWLRAIHSl6Ek8QgK4QegQIBhAB&uact=5&oq=Session+vs+Token+Authentication+%D1%80%D0%B0%D1%81%D0%BA%D1%80%D0%BE%D0%B9+%D0%BC%D0%BD%D0%B5+%D1%8D%D1%82%D1%83+%D1%82%D0%B5%D0%BC%D1%83&gs_lp=Egxnd3Mtd2l6LXNlcnAiRVNlc3Npb24gdnMgVG9rZW4gQXV0aGVudGljYXRpb24g0YDQsNGB0LrRgNC-0Lkg0LzQvdC1INGN0YLRgyDRgtC10LzRgzIFEAAY7wUyBRAAGO8FMggQABiABBiiBDIFEAAY7wVIt5YPULzqDljzlA9wAXgBkAEAmAGTAqABxB2qAQYwLjE4LjS4AQPIAQD4AQL4AQGYAhegApsewgIKEAAYsAMY1gQYR8ICChAAGIAEGAoYywHCAgYQABgWGB7CAgUQIRigAZgDAIgGAZAGCJIHBjEuMTcuNaAHvlCyBwYwLjE3LjW4B5YewgcGMC4yMS4yyAct&sclient=gws-wiz-serp&mstk=AUtExfDvj_qKwpFcqXhSCFrIbywH5AWXFGCzod62nyoJ7S7ABbLmUjmMER_hRPS1EZDtNT89TT5gRxyijroAGiiyWrAfUCoe_pStSfKqvBLa_souh5HQY-ZxA50wz1sKbLJhYEWMEIaVXfLonQ_AuZcMDnDERHRw3a3SdR3qk9Yg-xZZDamCJQ9dQva2sMHNccXg5cJwuRLcvmSNTdSNsRFXKjQTYCR2YQoiVpHrZkpeOdKh29Akbli6AtuDt3jTv_dcZAqYBxwVQ8r1qjov8_282qGn&csui=3)) и отправляет его клиенту. Этот токен содержит зашифрованные данные о пользователе (например, его идентификатор, права) и подписан серверной подписью, что гарантирует его подлинность. Клиент отправляет этот токен с каждым последующим запросом, и сервер, не обращаясь к базе данных, может проверить подлинность токена, используя его цифровую подпись.
- **Преимущества:**
    - **Без состояния (stateless):** Серверу не нужно хранить информацию о каждом активном сеансе, так как все необходимое содержится в самом токене. Это значительно упрощает масштабирование и использование в распределенных системах.
    - **Более высокая производительность:** Серверу не нужно делать запрос к базе данных при каждом запросе пользователя, что ускоряет процесс.
- **Недостатки:**
    - **Невозможность мгновенной отмены:** Токен остается действительным до истечения срока его действия. Для отзыва токена досрочно требуются дополнительные механизмы, например, поддержка "черного списка" на сервере.
    - **Увеличение нагрузки:** Токены (например, JWT) могут быть достаточно большими, и их передача в каждом запросе увеличивает нагрузку на сеть и трафик.

### JWT-Token

JWT-токен (JSON Web Token) — это **компактный и безопасный способ передачи данных между сторонами в виде JSON-объекта**. Он используется для аутентификации и авторизации в клиент-серверных приложениях, позволяя серверу проверять личность пользователя без необходимости каждый раз обращаться к базе данных.

**Структура JWT-токена**

JWT состоит из трех частей, разделенных точкой (`.`):

1. **Заголовок (Header):** Содержит информацию об алгоритме шифрования и типе токена.
2. **Полезная нагрузка (Payload):** Представляет собой набор данных в формате JSON, который может включать информацию о пользователе (например, имя, роль) и время жизни токена.
3. **Подпись (Signature):** Создается с помощью секретного ключа и алгоритма, указанных в заголовке. Эта подпись используется для проверки того, что токен не был изменен.

**Как это работает**

- Пользователь аутентифицируется, и сервер генерирует JWT-токен, подписывая его секретным ключом.
- Сервер отправляет этот токен пользователю.
- При каждом последующем запросе к защищенным ресурсам пользователь отправляет этот токен серверу.
- Сервер проверяет подлинность токена с помощью своей секретной подписи и, если токен валиден, предоставляет доступ к ресурсу.

**Преимущества использования**

- **Безопасность:** Подпись обеспечивает целостность данных, а ограниченный срок жизни токена снижает риск перехвата.
- **Производительность:** Не требует обращения к базе данных для каждой проверки, что ускоряет обработку запросов.
- **Автономность:** Токен содержит всю необходимую информацию, что делает его самодостаточным.

Примеры JWT-токенов **включают:**

- **Токены доступа (Access Tokens):** Используются для авторизации запросов к API и обычно имеют короткий срок действия (около 15 минут).
- **Токены обновления (Refresh Tokens):** Позволяют получить новый набор access и refresh-токенов, имеют более длительный срок действия (несколько дней).
- **Токены-носители (Bearer Tokens):** Частный случай access-токена, который обычно передается в заголовке `Authorization: Bearer <token>`.

**Преимущества использования Bearer Tokens**

- **Безопасность:** Токены часто имеют ограниченный срок действия и могут быть зашифрованы, что повышает безопасность по сравнению с базовой аутентификацией.
- **Гибкость:** Bearer-токены могут содержать различную информацию, например, о правах пользователя, что позволяет гибко управлять доступом к ресурсам.
- **Отсутствие сессий:** Сервер не хранит информацию о сессии, а проверяет каждый запрос отдельно, что упрощает масштабирование.

### OAuth 1 & OAuth 2

![image.png](image%20575.png)

OAuth — это открытый стандарт авторизации, а не API или сервис. Он позволяет приложениям получать ограниченный доступ к данным пользователей без передачи паролей. OAuth работает через HTTPS и использует токены доступа вместо учетных данных. Сегодня наиболее распространена версия OAuth 2.0.

![image.png](image%20576.png)

OAuth был создан как альтернатива прямой аутентификации, когда пользователи вводили свои логины и пароли непосредственно в сторонние приложения. Это называлось "антипаттерном пароля". OAuth решает проблему делегированной авторизации — позволяет приложениям получать доступ к данным без раскрытия пароля.

**Основные компоненты:**

- **Scope (области)** — наборы разрешений, которые приложение запрашивает
- **Токены доступа** — краткосрочные токены (часы/минуты) для обращения к API
- **Токены обновления** — долгосрочные токены (дни/месяцы/годы) для получения новых токенов доступа
- **Сервер авторизации** — главный движок OAuth
- **Владелец ресурса** — пользователь, которому принадлежат данные
- **Клиент** — приложение, желающее получить доступ к данным

![image.png](image%20577.png)

**Типы OAuth-потоков:**

1. **Authorization Code Flow** (золотой стандарт) — использует и фронт-канал, и бэк-канал, наиболее безопасный
2. **Implicit Flow** — для браузерных приложений, вся коммуникация через браузер
3. **Client Credentials Flow** — для сервер-сервер взаимодействия
4. **Resource Owner Password Flow** — устаревший режим с использованием логина/пароля

OAuth — это НЕ протокол аутентификации. Он решает задачу авторизации, а не определения личности пользователя. Для аутентификации был создан **OpenID Connect (OIDC)**, который расширяет OAuth 2.0, добавляя ID-токен и стандартизированные способы получения информации о пользователе.

**Безопасность:**

OAuth имеет большую поверхность атаки. Важно всегда использовать HTTPS, применять CSRF-токены, валидировать URI перенаправления и не раскрывать секреты клиентов в публичных приложениях.

![image.png](image%20578.png)

**OAuth 1.x**

- **Сложность:** Более сложная реализация, требующая цифровой подписи каждого HTTP-запроса.
- **Токены:** Токены доступа не имеют срока действия.
- **Область применения:** Изначально был разработан только для веб-сайтов.
- **Масштабируемость:** Не масштабируется так же эффективно, как OAuth 2.0.

**OAuth 2.x**

- **Сложность:** Значительно проще в реализации благодаря отсутствию необходимости в цифровых подписях для запросов. Безопасность обеспечивается с помощью HTTPS и токенов.
- **Токены:** Использует токены доступа с коротким сроком действия, что повышает безопасность. Для их обновления используется «токен обновления» без повторной авторизации пользователя.
- **Область применения:** Подходит как для веб-приложений, так и для мобильных и настольных приложений.
- **Масштабируемость:** Масштабируемость значительно улучшена по сравнению с первой версией.
- **Гибкость:** Предлагает несколько потоков авторизации (типов грантов) для разных сценариев использования.
- **Роли:** Произошло разделение ролей сервера: выделяются отдельно сервер авторизации и сервер, хранящий ресурсы.

### Session-Based Authentication

Сессионная аутентификация хранит данные сессии на сервере и использует сессионный ID (часто в cookie) для идентификации пользователя, в то время как токеновая аутентификация отправляет клиенту подписанный токен, содержащий необходимую информацию, и не требует хранения данных на сервере после выдачи. Основное отличие — **где хранится информация о сессии:** в **сессионной** она на **сервере**, в **токеновой** — в **клиенте**. 

**Сессионная аутентификация**

- **Как работает:**
    1. Пользователь входит в систему.
    2. Сервер создает уникальный идентификатор сессии и сохраняет его в своей памяти или базе данных.
    3. Сервер отправляет этот идентификатор клиенту в виде cookie.
    4. При каждом последующем запросе клиент отправляет cookie с идентификатором сессии обратно на сервер.
    5. Сервер проверяет идентификатор сессии и по нему определяет, что пользователь аутентифицирован.
- **Преимущества:**
    - Сервер контролирует сессию и может её отменить или обновить в любой момент.
- **Недостатки:**
    - Требует хранения состояния сессий на сервере, что может быть ресурсоемко для больших приложений.
    - Идентификаторы сессий могут быть уязвимы для атак, если cookie украдены.

**Токеновая аутентификация**

- **Как работает:**
    1. Пользователь входит в систему.
    2. Сервер создает токен (например, JWT) и отправляет его клиенту. Токен содержит информацию о пользователе и подписан криптографически для защиты от подделки.
    3. Клиент сохраняет токен (например, в Local Storage) и включает его в каждый последующий запрос, обычно в заголовок `Authorization`.
    4. Сервер проверяет подпись токена и его действительность, чтобы определить подлинность пользователя. Для этого ему не нужно обращаться к базе данных за сессией.
- **Преимущества:**
    - Серверу не нужно хранить состояние аутентификации, что облегчает масштабирование.
    - Токены могут быть самодостаточными и содержать всю необходимую информацию, что снижает количество запросов к базе данных.
- **Недостатки:**
    - Если токен потерян, серверу требуется время на отзыв всех токенов, выданных этому пользователю (если не настроена система их отзыва).
    - Токены должны быть достаточно длинными и сложными, чтобы избежать атак методом подбора.