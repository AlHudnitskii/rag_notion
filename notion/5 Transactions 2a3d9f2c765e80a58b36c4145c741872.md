# 5. Transactions

Категория: SQL Databases
Статус: Готово

Транзакции - фундаментальное понятие во всех СУБД. Суть транзакции в том, что она объединяет последовательность действий в одну операцию «всё или ничего». Промежуточные состояния внутри последовательности не видны другим транзакциям, и если что-то помешает успешно завершить транзакцию, ни один из результатов этих действий не сохранится в базе данных.

В Postgres транзакция определяется набором SQL-команд, окружённым командами `BEGIN` и `COMMIT` :

![image.png](image%20580.png)

Если в процессе выполнения транзакции мы решим, что не хотим фиксировать её изменения (например, потому что оказалось, что баланс Алисы стал отрицательным), мы можем выполнить команду `ROLLBACK` вместо `COMMIT`, и все наши изменения будут отменены.
Операторами в транзакции можно также управлять на более детальном уровне, используя *точки сохранения*. Точки сохранения позволяют выборочно отменять некоторые части транзакции и фиксировать все остальные. Определив точку сохранения с помощью `SAVEPOINT`, при необходимости вы можете вернуться к ней с помощью команды `ROLLBACK TO`. Все изменения в базе данных, произошедшие после точки сохранения и до момента отката, отменяются, но изменения, произведённые ранее, сохраняются.

### Проблемы параллельной работы транзакций:

- Фантомные чтения
- Неповторяющиеся чтения
- Грязные чтения

### Уровни изоляции транзакций

| READ UNCOMMITED | Разрешены фантомные, неповторяющиеся и грязные чтения |
| --- | --- |
| READ COMMITED | Разрешены фантомные и неповторяющиеся чтения, грязные запрещены |
| REPEATABLE READ | Разрешены фантомные чтения, неповторяющиеся и грязные запрещены |
| SERIALIZABLE | Запрещены фантомные, неповторяющиеся и грязные чтения |

ACID наряду с BASE - это набор правил, объясняющий как БД организованы, как они хранят и управляют данными. Обычно используется для описания свойств SQL-БД. 

![image.png](image%20581.png)

## А - Atomicity (Атомарность)

Каждая транзакция обрабатывается как единая операция. Все действия внутри транзакций либо выполнены полностью (COMMIT), либо не выполнены вообще (ROLLBACK).

![image.png](image%20582.png)

## C - Consistency (Согласованность)

Консистентность гарантирует нам, что все данные будут подчиняться набору правил. Если что-то их нарушает, будет отсекаться. Примеры правил:

![image.png](image%20583.png)

![image.png](image%20584.png)

## I - Isolation (Изоляция)

БД контролирует какие изменения конкурентные транзакции могут видеть друг у друга.  

Определяет целостность БД во время выполнения конкурентных транзакций.

![image.png](image%20585.png)

### Почему уровней изоляции несколько?

![image.png](image%20586.png)

Виды феноменов:

1. Lost update (Потерянное обновление) - Write-Write Conflict

![image.png](image%20587.png)

![image.png](image%20588.png)

Чтобы исправить проблему "потерянного обновления" без `SELECT FOR UPDATE`, **можно использовать оптимистический параллелизм путем проверки версии данных при обновлении или использовать уровень изоляции `SERIALIZABLE`, который гарантирует предотвращение этой аномалии путем предотвращения параллельных конфликтов**. 

1. Dirty read (Грязное чтение) - Write-Read Conflict

![image.png](image%20589.png)

![image.png](image%20590.png)

1. Non-repeatable Read (Неповторяемое чтение) - Read-Write Conflict

![image.png](image%20591.png)

Исправление Non-repeatable Read:

![image.png](image%20592.png)

1. Phantom Read (Фантомное чтение)

![image.png](image%20593.png)

Уровни изоляций (в Postges по умолчанию Read commited): 

![image.png](image%20594.png)

Важная P.S. В Postres уровень Repeatable Read защищает от Phantom Read (другие - нет), но не защищает от Serialization Anomaly.

Данная аномалия происходит, когда результат успешной фиксации группы транзакций оказывается несогласованным при всевозможных вариантах исполнения этих транзакций по очереди.

## D - Durability (Целостность)

Все закомиченные транзакции всегда в сохранности чтобы бы мы ни делали: выключено питание, сети нет. (Пример: Использование WAL).

![image.png](image%20595.png)

![image.png](image%20596.png)

## WAL (Write-ahead log)

Увы, чудес не бывает: чтобы пережить потерю информации в оперативной памяти, все необходимое должно быть своевременно записано на диск. 

Поэтому сделано вот что. Вместе с изменением данных ведется еще и *журнал* этих изменений. Когда мы что-то меняем на странице в буферном кеше, мы создаем в журнале запись об этом изменении. Запись содержит минимальную информацию, достаточную для того, чтобы при необходимости изменение можно было повторить.
Данные, которые обязательно нужно журналировать:

- изменение страниц в буферном кэше
- фиксация и отмена транзакций
- файловые операции

Что НЕ нужно фиксировать:

- операции с нежурналируемыми страницами
- операции с временными таблицами

### **Логическое устройство**

Логически журнал можно представить в виде последовательности записей различной длины. Каждая из записей содержит данные о некоторой операции, предваренные заголовком, в котором указаны:

- Номер транзакции, к которой относится запись
- Менеджер системы
- Контрольная сумма - позволяет определить повреждение данных
- Длина записи и ссылка на предыдущую запись.

![image.png](image%20597.png)

### **Физическое устройство**

На диске журнал хранится в виде файлов в каталоге $PGDATA/pg_wal. Каждый файл по умолчанию занимает 16 Мб. Журнальные записи попадают в текущий использующийся файл; когда он заканчивается — начинает использоваться следующий.

### **Восстановление**

Когда мы стартуем сервер, первым делом запускается процесс postmaster, а он, в свою очередь, запускает процесс startup, задача которого — обеспечить восстановление, если произошел сбой.

Чтобы определить, требуется ли восстановление, startup заглядывает в специальный управляющий файл $PGDATA/global/pg_control и смотрит на статус кластера.

У аккуратно остановленного сервера статус будет «shut down». Если сервер не работает, а статус остался «in production», это означает, что СУБД упала и тогда автоматически будет выполнено восстановление.

Для восстановления процесс startup будет последовательно читать журнал и применять записи к страницам, если в этом есть необходимость.

### **Зачем нужен WAL**

- **Целостность данных:** Гарантирует, что даже при сбое на диске, база данных не потеряет данные.
- **Восстановление после сбоя:** Позволяет восстановить базу данных до последней зафиксированной транзакции.
- **Репликация:** Является основой для потоковой репликации, так как файлы WAL могут передаваться на реплицируемые серверы.
- **Резервное копирование:** Позволяет выполнять непрерывное архивирование (Point-in-Time Recovery — PITR), что дает возможность восстановить базу данных на любой момент времени.