# 4. Docker: Networks

Категория: Docker & Kubernetes
Статус: Проверено

Сетевое взаимодействие — это общение между процессами и контейнерами. Сетевая связь Docker в основном используется для установки связи между контейнерами Docker и связи с внешним миром.

Docker обрабатывает связь между контейнерами, создавая сеть мостов по умолчанию, в большинстве случаев этого достаточно для нормальной работы.

### Типы сетевых драйверов:

- **`bridge`** -  это сетевой драйвер по умолчанию. Бридж сеть используется, когда приложения запускаются в автономных контейнерах, которые должны взаимодействовать между собой, наглядный пример Nginx + MySQL. Общение по сети происходит в помощью NAT.
- **`host`** - это сетевой драйвер для автономных контейнеров, удаленная сетевая изоляция между контейнером и Docker-хостом. Данный драйвер доступен только для docker-swarm с поддержкой Docker 17.06 и выше.
- **`overlay` -** это сетевой драйвер для соединения несколько демонов Docker между собой и которые позволяют docker-swarm службам взаимодействовать друг с другом (Используется для kubernetes), вне зависимости от того, где они запущены.
- **`macvlan`** - это сетевой драйвер, который позволяют назначать MAC-адрес контейнеру, делая его отображаемым как физическое устройство в вашей сети. Docker демон направляет трафик на контейнеры по их MAC-адресам. Использование macvlan драйвера иногда является лучшим выбором при работе с устаревшими приложениями, которые ожидают, что они будут напрямую подключены к физической сети.
- **`none`** - это сетевой драйвер, который умеет отключать всю сеть для контейнеров. Docker создает контейнер без сетевого интерфейса. Пример, контейнеры, выполняющие вычислительные задачи, не требующие сетевых ресурсов, либо для полной безопасности.

P.S. *Docker Swarm — это встроенный инструмент оркестрации контейнеров, который преобразует кластер узлов Docker в единый виртуальный хост.*

### Port publishing vs container-to-container

Публикация портов (Port Publishing) (например, `-p 8080:80`) открывает порт контейнера (80) во внешний мир через порт хоста (8080), делая приложение доступным извне. 

Тогда как связь контейнер-контейнер (Container-to-Container) (по умолчанию через внутреннюю Docker-сеть, например, `http://<имя_контейнера_app>:80`) позволяет контейнерам общаться друг с другом без exposing портов наружу, используя DNS-разрешение имен в изолированной сети, что безопаснее и эффективнее для микросервисов. 

**Публикация портов (Port Publishing / Port Mapping)**

- **Что это:** Сопоставление порта внутри контейнера с портом на хост-машине (сервере).
- **Команда:** `docker run -p <хост_порт>:<контейнер_порт> ...` (например, `p 8080:80`).
- **Назначение:** Сделать сервис, работающий в контейнере (например, веб-сервер на порту 80), доступным извне Docker-хоста, через определенный порт хоста (например, 8080).
- **Пример:** `docker run -p 8080:80 nginx` — доступ к Nginx через `http://localhost:8080`.

**Связь контейнер-контейнер (Container-to-Container)**

- **Что это:** Взаимодействие между контейнерами, находящимися в одной Docker-сети.
- **Как работает:**
    - Docker создает внутреннюю, изолированную сеть.
    - Каждый контейнер получает DNS-имя (обычно имя контейнера или имя сервиса).
    - Контейнеры могут обращаться друг к другу, используя эти имена и порты *внутри* контейнера (например, `http://my-backend:3000`).
- **Назначение:** Безопасная коммуникация микросервисов внутри кластера или одной сети, без «выставления» внутренних портов вовне.
- **Пример:** База данных (db) и веб-приложение (app) в одной сети: `app` обращается к `db` по `http://db:5432` (5432 - порт PostgreSQL).

**Ключевое различие**

- **Порт-публикация** — для **внешнего** доступа к контейнеру извне Docker-хоста.
- **Контейнер-контейнер** — для **внутреннего** взаимодействия контейнеров между собой, без необходимости открывать порты вовне (по умолчанию).