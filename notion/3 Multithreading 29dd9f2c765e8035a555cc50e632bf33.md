# 3. Multithreading

Категория: Python Async & Related
Статус: В процессе

Поток - наименьшая единица выполнения, которая может управляться операционной системой. У потоков памяти нет, они пользуются памятью создавшего их процесса.  

Потоки ассоциированы с процессом, создавшим их. С каждым процессом всегда ассоциирован по меньшей мере один поток, обычно называемый главным. Процесс может создавать дополнительные потоки, которые обычно называются рабочими или фоновыми.

![image.png](image%20223.png)

Процессы могут порождать дополнительные потоки, разделяющие память со своим процессом-родителем. Они могут конкурентно выполнять другую работу, это называется многопоточностью.

![image.png](image%20224.png)

Многопоточные приложения - обычный способ реализации конкурентности во многих языках программирования. Но в Python есть несколько препятствий на пути организации конкурентности с помощью потоков. Многопоточность полезна только для задач, ограниченных производительностью ввода-вывода, потому что нам мешает глобальная блокировка интерпретатора.

**Написал многопоточную программу на Python**

Ожидание 

![image.png](image%20225.png)

Реальность

![image.png](image%20226.png)

Почему так? - Все дело в GIL  

**GIL (Global Interpreter Lock)** — это главная особенность CPython, которая позволяет только одному потоку исполнять байт-код Python в один момент времени.

### Когда потоки эффективны:

- **I/O-bound задачи**: сетевые запросы, чтение/запись файлов, работа с БД
- Операции, где программа большую часть времени ждёт (network, disk)

### Когда потоки НЕэффективны:

- **CPU-bound задачи**: вычисления, обработка данных
- Здесь нужен `multiprocessing` или асинхронность

### Основные инструменты работы с многопоточностью:

1. Модуль `threading` 

![image.png](image%20227.png)

Еще методы для работы с потоками:

![image.png](image%20228.png)

![image.png](image%20229.png)

Гарантирует изолированность данных внутри потока.

1. Модуль `сoncurrent.futures` 

![image.png](image%20230.png)

1. **`run_in_executor` из модуля `asyncio` . Это метод для выполнения синхронного кода в пуле потоков/процессов.**

![image.png](image%20231.png)

![image.png](image%20232.png)

Синхронизация
1. **Lock** — базовая блокировка

![image.png](image%20233.png)

`Thread.Lock` в Python **используется для синхронизации потоков, чтобы предотвратить одновременный доступ к общим ресурсам и избежать состояния гонки** (race condition).

1. **RLock** (Reentrant Lock) — можно захватывать несколько раз одним потоком
2. **Semaphore** — ограничивает количество одновременных доступов
3. **Event** — сигнализация между потоками
4. **Condition** — более сложная синхронизация с ожиданием условий

**Частые вопросы**

1. **Чем отличается `threading` от `multiprocessing`?**
    - threading: общая память, GIL, для I/O
    - multiprocessing: отдельные процессы, нет GIL, для CPU-bound
2. **Thread-safe структуры данных:**
    - `queue.Queue` — потокобезопасная очередь
    - Обычные list, dict НЕ полностью thread-safe для сложных операций
3. **Daemon потоки:**
    - `thread.daemon = True` — завершаются при выходе из программы
    - Используются для фоновых задач
4. **Thread locals:**
    - `threading.local()` — данные, уникальные для каждого потока

## Типичные проблемы:

- **Race conditions** — когда результат зависит от порядка исполнения потоков.

Классический пример - изменение банковского счета.

- **Deadlock** — взаимная блокировка потоков.

![image.png](image%20234.png)

- **Starvation** — поток не может получить доступ к ресурсу.

Демоны  – это специальный вид потоков, предназначенный для выполнения длительных фоновых задач. Они не мешают приложению завершиться. На самом деле если работают только потоки-демоны, то приложение вообще завершается автоматически. Главный поток Python не является демоном, но если все потоки обслуживания подключений сделать демонами, то приложение завершится при возникновении KeyboardInterrupt. Перейти на потоки-демоны просто – нужно лишь написать thread.daemon = True перед выполнением
thread.start(). После этого изменения приложение будет правильно завершаться при нажатии CTRL+C.