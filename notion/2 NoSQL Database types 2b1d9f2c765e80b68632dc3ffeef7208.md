# 2. NoSQL Database types

Категория: NoSQL & General theory
Статус: Готово

Модель NoSQL появилась в ответ на необходимость оперативно обрабатывать действительно огромные объёмы данных. Поэтому NoSQL по большей части заточена под масштабирование по горизонтали и работу с недостаточно структурированными или постоянно меняющимися данными.

### **Плюсы NoSQL**

- Гибкость - возможность группировки любого набора данных и их связей. Объект данных при этом может быть многосоставным: нормализация в NoSQL не требуется.
- Доступность данных - благодаря механизмам отказоустойчивости секций, в том числе репликации и шардированию, NoSQL способна в любой момент обслужить входящий запрос и вернуть не ошибочный ответ.
- Лучшая масштабируемость - поскольку между записями в NoSQL нет жёсткой связи, данные можно дробить и хранить на нескольких независимых серверах. Горизонтальное масштабирование легче и дешевле, чем вертикальное, присущее SQL-моделям.
- Высокая производительность - благодаря оптимизации баз под определённые виды моделей данных скорость представления информации часто превосходит скорость SQL-базы. Например, если необходимые записи хранятся в одном документе, больше нет потребности в операции JOIN.
- Экономия ресурсов - горизонтальное масштабирование позволяет сократить количество дорогостоящих серверов.

### Key-value store (Ключ-значение)

В этой БД записи хранятся в парах «ключ — значение», где ключ выступает уникальным идентификатором. Ключи и значения фиксируются в виде простой или составной информации. Эти хранилища максимально быстро реагируют на запросы информации и прекрасно масштабируются.

Key-value СУБД часто используется для систем, в которых скорость является приоритетом, а данные не слишком сложные. Например, для хранения кеша данных, онлайн-списков, обработки истечения срока действия, разделения сеансов, построения рейтинга и прочих задач.

![image.png](image%20750.png)

### Redis

Redis (Remote Dictionary Server) — это высокопроизводительное хранилище данных типа "ключ-значение" в оперативной памяти, которое может использоваться как база данных, кэш и брокер сообщений. Redis известен своей скоростью, простотой использования и богатым набором структур данных.

### Типы данных (datatypes)

![image.png](image%20751.png)

**String (Строки)** — самый простой тип данных, может хранить текст, числа или бинарные данные до 512 МБ. Используется для кэширования, счётчиков, сессий.

**Lists (Списки)** — упорядоченные коллекции строк, реализованные как связные списки. Подходят для очередей задач, лент активности, истории действий.

**Sets (Множества)** — неупорядоченные коллекции уникальных строк. Отлично подходят для отслеживания уникальных элементов, тегов, связей между объектами.

**Sorted Sets (Упорядоченные множества)** — множества с присвоенным каждому элементу числовым весом (score), элементы автоматически упорядочиваются. Используются для рейтингов, лидербордов, диапазонных запросов.

**Hashes (Хэши)** — коллекции пар "поле-значение", идеальны для представления объектов с несколькими полями.

**Bitmaps (Битовые массивы)** — операции на уровне битов над строками. Эффективны для аналитики присутствия пользователей, флагов.

**HyperLogLogs** — вероятностная структура для подсчёта уникальных элементов с минимальным использованием памяти.

**Streams** — структура данных для работы с потоками событий, похожая на лог, поддерживает группы потребителей.

**Geospatial indexes** — хранение и запросы географических координат с поддержкой поиска по радиусу.

### Хранение информации (RAM, Disk)

Redis по умолчанию хранит все данные в оперативной памяти, что обеспечивает чрезвычайно быструю работу с микросекундной задержкой. Все операции чтения и записи происходят непосредственно в RAM (random access memory).

Тут важно понять то, что чтение данных из памяти и работа с данными, находящимися в памяти, гораздо быстрее чем те же операции, выполняемые традиционными СУБД, использующими обычные жёсткие диски (HDD) или твердотельные накопители (SSD).

![image.png](image%20752.png)

Механизмы сохранения данных на диск от Redis (персистентность):

- RDB (Redis Database) - создаёт снимки (snapshots) данных через определённые интервалы времени. Файл RDB компактен и подходит для резервного копирования. Минус: возможна потеря данных между снимками при сбое.
- AOF (Append Only File) — логирует каждую операцию записи в файл. Более надёжен с точки зрения сохранности данных. Можно настроить частоту синхронизации: каждую секунду, каждый запрос или без синхронизации.
- Гибридный режим (RDB+AOF) — с Redis 4.0 можно использовать комбинацию: RDB для быстрого восстановления и AOF для минимизации потерь данных.

Тем не менее, когда Redis используется исключительно как кэш, он поддерживает работу без персистентности.

### Redis vs Memcached

Главные различия между ним и Redis заключаются в том, что в Memcached имеется меньше типов данных, и в ограничениях, связанных с политикой вытеснения ключей. Memcached поддерживает лишь политику LRU (Least Recently Used), когда первыми вытесняются данные, которые не использовались дольше всех.

![image.png](image%20753.png)

### Время жизни ключей (Key lifetime)

Redis позволяет устанавливать время жизни (TTL - Time To Live) для ключей:

**Команды для установки TTL:**

- `EXPIRE key seconds` — установить время жизни в секундах
- `EXPIREAT key timestamp` — установить точное время истечения (Unix timestamp)
- `PEXPIRE key milliseconds` — установить время жизни в миллисекундах
- `TTL key` — узнать оставшееся время жизни ключа
- `PERSIST key` — убрать ограничение времени жизни

**Поведение при истечении:**
Когда время жизни ключа истекает, Redis автоматически удаляет его. Это происходит двумя способами:

- **Пассивное удаление** — ключ удаляется при попытке доступа к нему
- **Активное удаление** — Redis периодически проверяет случайные ключи и удаляет истекшие

**Применение:**
TTL широко используется для кэширования данных, сессий пользователей, временных токенов, ограничения частоты запросов (rate limiting).

### Redis Cluster

Redis Cluster - это встроенное решение для горизонтального масштабирования и обеспечения высокой доступности.

![image.png](image%20754.png)

*Кластер Redis. Клиенты выполняют операции чтения/записи, взаимодействуя с ведущими (M1, M2, M3) узлами Redis. Между ведущими и подчинёнными (S1, S2, S3) выполняется репликация данных. Другие клиенты, обращаясь к подчинённым узлам, выполняют операции чтения данных. Для определения общего состояния кластера используется протокол Gossip.*

После того, как мы решили использовать Redis Cluster, это будет значить, что мы решили распределить хранимые нами данные по множеству машин. Это называют шардингом. В результате каждый экземпляр Redis, входящий в состав кластера, считается хранилищем шарда, или фрагмента, всех данных.

Такой подход вызывает к жизни новую проблему. Если отправить в кластер данные — как узнать о том, какой именно экземпляр Redis (шард) хранит эти данные? Есть несколько способов это сделать. Redis Cluster использует алгоритмический шардинг.

Для того чтобы найти шард для заданного ключа, мы хешируем ключ, а результат делим по модулю на количество шардов. Затем, используя детерминистическую хеш-функцию, мы, когда нужно будет прочитать соответствующие данные, сможем узнать о том, где именно они хранятся.

Что произойдёт, если через некоторое время в систему будет добавлен новый шард? А произойдёт то, что называют решардингом.

В рамках Redis Cluster создан механизм, направленный на решение этой проблемы. Это — так называемые «хеш-слоты», в которые и отправляют данные. Имеется около 16 тысяч таких слотов. Это даёт нам адекватный способ распределения данных по кластеру, а при добавлении новых шардов нужно просто переместить в системе хеш-слоты. Поступая так, нам нужно лишь перемещать хеш-слоты из шарда в шард и упростить процесс добавления новых ведущих экземпляров Redis в кластер.

**Протокол Gossip**

Redis Cluster использует протокол Gossip для определения общего состояния кластера. На вышеприведённой иллюстрации имеется 3 ведущих (M) узла и 3 подчинённых (S) узла. Все эти узлы постоянно обмениваются друг с другом информацией для того чтобы знать о том, какие шарды доступны и готовы обрабатывать запросы. Если достаточное количество шардов согласно с тем, что узел M1 не отвечает на запросы, они могут решить повысить S1 — подчинённый узел узла M1, до уровня ведущего узла, чтобы поддержать кластер в работоспособном состоянии. Количество узлов, необходимое для запуска подобной процедуры, поддаётся настройке. Очень важно правильно выполнить подобную настройку. Если сделать что-то не так, можно оказаться в ситуации, когда кластер окажется разделённым на части в том случае, если он не сможет разрешить неоднозначную ситуацию, когда «за» и «против» голосует одинаковое количество систем. Этот феномен называют «split brain» (разделение вычислительных мощностей). Поэтому, в качестве общего правила, важно, чтобы в кластере было бы нечётное количество ведущих узлов, у каждого из которых имеется два подчинённых узла. Это послужит хорошей основой для построения надёжной системы.

Ограничения:

- Не поддерживаются операции с несколькими ключами из разных хэш-слотов.
- Нет поддержки множественных баз данных (только database 0).

**Альтернативы:** Redis Sentinel — более простое решение для мониторинга и автоматического failover без шардирования.

### Memory overflowing

Когда Redis достигает лимита памяти (установленного через `maxmemory`), он применяет политики вытеснения (eviction policies):

**Политики вытеснения:**

- **noeviction** — возвращает ошибку при попытке записи, если память заполнена. Команды чтения продолжают работать.
- **allkeys-lru** — удаляет наименее используемые (Least Recently Used) ключи среди всех ключей.
- **volatile-lru** — удаляет LRU ключи только среди тех, у которых установлен TTL.
- **allkeys-lfu** — удаляет наименее часто используемые (Least Frequently Used) ключи среди всех ключей.
- **volatile-lfu** — удаляет LFU ключи только среди тех, у которых установлен TTL.
- **allkeys-random** — удаляет случайные ключи.
- **volatile-random** — удаляет случайные ключи среди тех, у которых установлен TTL.
- **volatile-ttl** — удаляет ключи с наименьшим оставшимся временем жизни (TTL).

**Рекомендации:**

- Для кэша: используйте `allkeys-lru` или `allkeys-lfu`
- Если используете TTL для временных данных: `volatile-lru` или `volatile-ttl`
- Мониторьте использование памяти через команду `INFO memory`

### Redis Transactions

Redis поддерживает транзакции через команды MULTI, EXEC, DISCARD и WATCH (UNWATCH).

- MULTI - Начинает транзакцию. Все команды, которые следуют за `MULTI`, будут помещены в очередь и не будут выполнены немедленно (Вложенность не поддерживается).
- EXEC - Запускает выполнение всех команд, которые были помещены в очередь после `MULTI`. Если не возникает ошибок, все команды выполняются последовательно и атомарно.
- DISCARD - Отменяет транзакцию, удаляя все команды из очереди.
- WATCH **-**  Позволяет отслеживать один или несколько ключей. Если другой клиент изменит какой-либо из этих ключей между вызовом `WATCH` и `EXEC`, транзакция будет отменена, чтобы обеспечить целостность данных.
- UNWATCH - Снимает все ключи, установленные для просмотра с помощью команды `WATCH`.

Характеристики:

- Атомарность - Все команды в транзакции выполняются последовательно как единое целое.
- Отсутствие отката - Если команда в транзакции завершается с ошибкой, Redis НЕ откатывает предыдущие команды. Это отличается от SQL-транзакций.

### Redis Blocking

Redis предоставляет блокирующие операции, особенно полезные для реализации очередей:

**Блокирующие команды списков:**

- **BLPOP key [key ...] timeout** — блокирующий POP из левой части списка. Ожидает появления элемента в течение timeout секунд.
- **BRPOP key [key ...] timeout** — блокирующий POP из правой части списка.
- **BRPOPLPUSH source destination timeout** — атомарно извлекает элемент из конца одного списка и помещает в начало другого, с блокировкой.
- **BLMOVE source destination LEFT|RIGHT LEFT|RIGHT timeout** — блокирующее перемещение элемента между списками.

**Блокирующие команды Streams:**

- **XREAD BLOCK milliseconds** — блокирующее чтение из потока.
- **XREADGROUP BLOCK milliseconds** — блокирующее чтение для группы потребителей.

**Применение:**

- Реализация очередей задач (task queues)
- Паттерн "производитель-потребитель"
- Системы обмена сообщениями
- распределенные системы

**Особенности:**

- Timeout 0 означает бесконечное ожидание
- Можно указать несколько ключей, команда вернётся при появлении данных в любом из них
- Блокирующие операции не блокируют сам сервер Redis — он продолжает обрабатывать другие запросы

### Redis Pub/Sub

**Pub/Sub (Publisher-Subscriber)** — это архитектурный паттерн, который упрощает взаимодействие между компонентами сложных распределённых систем, разделяя отправителей (издателей) и получателей (подписчиков) сообщений. В отличие от прямого обмена данными между компонентами, модель Pub/Sub создает слой абстракции, где один компонент публикует сообщение, а другие компоненты подписываются на его получение. При этом издатели и подписчики могут существовать независимо друг от друга, не зная о точном местоположении и количестве участников.

**Основные команды:**

- **PUBLISH channel message** — отправить сообщение в канал. Возвращает количество подписчиков, получивших сообщение.
- **SUBSCRIBE channel [channel ...]** — подписаться на один или несколько каналов.
- **UNSUBSCRIBE [channel ...]** — отписаться от каналов.
- **PSUBSCRIBE pattern [pattern ...]** — подписаться на каналы по шаблону (например, `news.*` для `news.sports`, `news.tech`).
- **PUNSUBSCRIBE [pattern ...]** — отписаться от шаблонов.
- **PUBSUB CHANNELS [pattern]** — получить список активных каналов.
- **PUBSUB NUMSUB [channel ...]** — количество подписчиков на канал.

**Характеристики:**

- **Fire-and-forget:** Сообщения не сохраняются. Если подписчика нет в момент публикации, он не получит сообщение.
- **Нет очередей:** Это не система очередей задач. Для надёжной доставки используйте Redis Streams.
- **Производительность:** Очень быстрая система для real-time коммуникации.
- **Масштабируемость:** В Redis Cluster pub/sub работает глобально — сообщения распространяются на все узлы.

**Применение:**

- Чаты и системы real-time уведомлений
- Синхронизация между микросервисами
- Инвалидация кэша

**Альтернатива:** Для гарантированной доставки сообщений лучше использовать Redis Streams или специализированные брокеры сообщений (RabbitMQ, Kafka).

### Распределенные блокировки в Redis

Распределенные блокировки — это примитив, необходимый для обеспечения **взаимного исключения**, когда разные процессы должны безопасно работать с общими ресурсами.

Алгоритм Redlock стремится обеспечить минимальные гарантии:
    ◦ **Безопасность:** В любой момент времени только один клиент может удерживать блокировку.
    ◦ **Доступность :** Блокировку всегда можно получить, даже если клиент, удерживающий её, отказал.
    ◦ **Отказоустойчивость:** Клиенты могут приобретать и высвобождать блокировки, пока работает большинство узлов Redis.

Простая схема с одним мастером и асинхронными репликами не гарантирует безопасность. Если мастер падает до репликации ключа, реплика может стать новым мастером, и другой клиент сможет получить ту же блокировку, нарушая взаимное исключение.

**Основа: Правильная Блокировка в Единственном Инстансе**
Для безопасной работы даже с одним инстансом Redis используется следующий подход, который лежит в основе Redlock:
• **Acquire:** Используется команда `SET [ресурс] [уникальное_значение] NX PX [время_жизни]`.
    ◦ `NX`: устанавливает ключ, только если он не существует.
    ◦ `PX`: задает автоматическое время жизни ключа (срок действия блокировки).
    ◦ `[уникальное_значение]`: Случайная строка, которая "подписывает" блокировку и обеспечивает безопасное снятие.
• **Release:** Использовать команду `DEL` небезопасно. Вместо этого применяется **скрипт Lua**, который удаляет ключ, **только если его значение совпадает** с тем, которое установил клиент. Это предотвращает случайное снятие блокировки, которая уже истекла и была получена другим клиентом.
****

**Алгоритм Redlock (Распределенная Реализация)**
Redlock использует **N независимых мастер-инстансов Redis** (например, 5), которые не используют асинхронную репликацию.

**Шаги для получения блокировки:**
1. Клиент записывает текущее время ($T_{старт}$).
2. Клиент пытается последовательно или параллельно получить блокировку на **всех N инстансах**, используя одинаковое имя ресурса и уникальное значение. Время ожидания ответа должно быть коротким.
3. Клиент вычисляет время, потраченное на получение блокировок ($T_{затрачено} = T_{текущее} - T_{старт}$).
4. **Успешное получение блокировки** происходит только при двух условиях:
    ◦ Блокировка получена на **большинстве инстансов** (как минимум $N/2 + 1$).
    ◦ Общее время, затраченное на получение большинства блокировок ($T_{затрачено}$), **меньше** исходного времени жизни блокировки.
5. Если блокировка успешно получена, её фактительный срок действия уменьшается на $T_{затрачено}$.
6. **Если блокировка не получена** (не набрано большинство или истекло слишком много времени), клиент должен **немедленно высвободить** все блокировки, которые он успел установить, и повторить попытку после случайной задержки.

**Снятие блокировки:**
• Клиент высвобождает блокировку на **всех N инстансах** (используя безопасный Lua-скрипт), независимо от того, удалось ли ему успешно установить блокировку на этом инстансе.

## **Документоориентированные базы данных (Document-oriented store)**

В БД этого типа данные записываются в документы и хранятся в формате, подобном JSON. Таким хранилищам свойственны иерархичность (документы складываются в коллекции, а коллекции группируются логически) и гибкость (значения, свойства и их структура может меняться в процессе разработки).

![image.png](image%20755.png)

Document-oriented-модель хороша в проектах, где нужно обрабатывать большой объём данных без четкой структуры, а также для работы со множеством уникальных документов, которые со временем требуют изменений. Например, для каталогов товаров, соцсетей, платформ с блогами и видео, геоаналитики и в других сферах.

### MongoDB

MongoDB — это кроссплатформенная документо-ориентированная система управления базами данных. Относясь к категории NoSQL, MongoDB отказывается от традиционной таблично-ориентированной структуры реляционных баз данных в пользу JSON-документов с динамическими схемами, что делает интеграцию данных в приложениях более быстрой и простой.

### Storing information (documents, collections, BSON)

Document - Основная единица хранения, представляет собой структуру вида JSON, но фактически хранится в BSON.

Пример документа в Mongo:

![image.png](image%20756.png)

Collection - аналог таблицы в SQL, но без жёсткой схемы, содержит набор документов, которые в коллекции могут иметь разные поля.

**Разница между JSON и BSON**
Основное различие заключается в том, что **JSON — это текстовый формат, а BSON (Binary JSON) — его двоичное представление**. Это делает BSON более эффективным для хранения и быстрой обработки данных, поскольку он меньше по размеру и поддерживает больше типов данных, таких как `Date`, `ObjectId` и бинарные данные, в то время как JSON более удобочитаем для человека. 

### _id

Поле "_id" является негласным первичным ключом в MongoDB. И оно является уникальным значением. Если мы ничего не зададим в поле "_id", то оно систематически будет заполняться "MongoDB Id Object". 

`ObjectId` — 12-байтовый идентификатор, содержащий:

- timestamp
- machine id
- pid
- counter

Преимущества:

- Гарантированная уникальность
- Лёгкая сортировка по времени (ObjectId хранит timestamp)

Можно использовать свои `_id`: строки, числа, UUID.

### PyMongo basic operations (create, update, delete, find)

Подключение к таблице:

![image.png](image%20757.png)

**CRUD**

![image.png](image%20758.png)

![image.png](image%20759.png)

![image.png](image%20760.png)

![image.png](image%20761.png)

### Indexes

- Single field - по одному полю

![image.png](image%20762.png)

- Compound - по нескольким полям

![image.png](image%20763.png)

- Text index - полнотекстовой поиск

![image.png](image%20764.png)

- TTL index - автоудаление документов

![image.png](image%20765.png)

- Hashed index - для распределения при шардировании

Получение всего списка индексов

![image.png](image%20766.png)

### Aggregations

Aggregation Framework — мощный инструмент для обработки данных внутри MongoDB.

![image.png](image%20767.png)

Основные стадии:

- `$match` — фильтрация
- `$group` — группировка
- `$sort` — сортировка
- `$project` — выбрать нужные поля
- `$limit`
- `$lookup` — join
- `$unwind` — разворачивает массив

### `$lookup` (MongoDB join)

![image.png](image%20768.png)

Команда `$unwind` создает отдельный документ для каждого элемента этого массива. Например, если у вас есть документ с массивом пользователей `{"_id": 1, "user": ["Иван", "Мария"]}`, то после `$unwind` получится два документа: `{"_id": 1, "user": "Иван"}` и `{"_id": 1, "user": "Мария"}`. 

### Transactions

Транзакции позволяют выполнять несколько операций атомарно (all or nothing). Доступны:

- в replica set
- в sharded cluster

![image.png](image%20769.png)

![image.png](image%20770.png)

## Wide-column (Колоночные БД)

Эти БД имеют свои столбцы и строки, но информация записывается в колонки. Колонки между собой не связаны, поэтому удаление или добавление новых свойств не затрагивает остальную систему. Отсутствие заранее заданной схемы позволяет хранить в этих NoSQL-базах записи без чёткой структуры.

В традиционной СУБД при выполнении запроса сканируется вся таблица, а информация из всей строки извлекается целиком. В колоночных БД выгружаются только необходимые значения, поскольку поиск ведётся по отдельным столбцам. Такой подход колоночных NoSQL баз к хранению информации позволяет быстро получать данные из больших таблиц для анализа. А возможность сильного сжатия данных экономит много места на диске.

![image.png](image%20771.png)

В этой категории существуют базы ClickHouse, Vertica, Cassandra и другие.

ClickHouse не похожа на большинство других NoSQL баз данных, поскольку в качестве языка запросов использует SQL, пускай и немного модифицированный. Но в то же время благодаря столбцовому хранению данные из этой СУБД считываются только из нужных колонок, а физическая сортировка информации по первичному ключу помогает быстро получить конкретные значения или диапазоны. В отличие от традиционных СУБД ClickHouse позволяет построить кластер очень большого размера и обеспечить отказоустойчивость системы.

## **Графовые базы данных (graph store)**

Элементы базы данных хранятся в узлах (вершинах), между узлами существуют ребра, которые определяют отношения элементов друг к другу. У ребра есть начальный и конечный узел, направление и тип (связи действия, права владения, «родитель — ребёнок» и пр.). Главная особенность графовых БД — хранение не только сущностей данных, но и взаимосвязей, тогда как в реляционных БД соединения между элементами требует дополнительных вычислений.

![image.png](image%20772.png)

Благодаря такой модели данных graph store NoSQL используются для выполнения задач, ориентированных на связи: для алгоритмов рекомендаций контента, социальных сетей, обнаружения случаев сетевого мошенничества.

Для доступа к таким БД необходим язык запросов, но, поскольку общепринятых стандартов у NoSQL нет, для разных типов графовых баз данных понадобится индивидуальный подход. К графовым относятся базы данных Neo4j, OrientDB.

Наиболее популярными и базами временных рядов являются Prometheus, InflubDB, Graphite.

**Cypher** — это декларативный язык запросов, оптимизированный для графов, который используется в графовой СУБД **Neo4j**. Он похож на SQL, но ориентирован на описание шаблонов и взаимосвязей в графе. 

### Пример запроса

![image.png](image%20773.png)

## Time-series (InfluxDB, AWS Timestream, TimescaleDB)

Если у вас есть упорядоченные по времени данные с временными метками, такие как метрики от инфраструктуры или данные датчиков, может быть полезно использовать одну из баз данных временных рядов.

![image.png](image%20774.png)

Общие характеристики баз данных временных рядов:

- Данные временных рядов всегда собираются на протяжении определенного периода времени.
- Данные из рабочих нагрузок являются новыми и записываются как вставки. Уже существующие данные не обновляются путем замены.
- Когда данные записываются, они автоматически назначаются последнему интервалу времени.

Базы даных временных рядов часто используются для осуществления мониторинга различных метрик (будь то загрузка CPU, или показатели работы какого-либо датчика).

Наиболее популярными и базами временных рядов являются Prometheus, InflubDB, Graphite.

## Search (Elasticsearch)

Eсли вам необходимо осуществлять поиск большим объемам данных, особенно неструктурированным, как пример поиск по нескольким терабайтами логов, то вам может пригодиться использовать базу данных, совмещающую с функционалом хранения информации еще и функционал поиска по текстам.

Представим, что у вас есть N петабайт логов (или других текстовых данных). Обычный поиск по словам уже не подойдет, чтобы осуществить поиск и аналитику в разумное время.

На помощь приходит индексирование. Если очень утрировано его рассмотреть, можно его представить следующим способом. Каждому слову/лемме/n-грамме присвоим индекс и запишем эти индексы в специальную таблицу, где строки, это документ, а в столбики это индексы. Похожая система используется для построения систем поиска плагиата, правда там чаще применяют не слова, а шинглы (индексы с наслоением).

![image.png](image%20775.png)

А искать по индексу существенно быстрее, чем по совпадению по словам в документах.

Строго говоря, для поиска по документам можно использовать и эмбеддинги нейронных сетей, в которых закодирован "смысл" высказываний. Но для данной задачи лучше подойдут векторные базы данных, которые замыкают наш список.

Разумеется, современные поисковые СУБД предлагают значительно более широкий функционал. Наиболее популярное решение - Elasticsearch.