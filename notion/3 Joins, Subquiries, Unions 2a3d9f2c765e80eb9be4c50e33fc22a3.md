# 3. Joins, Subquiries, Unions

Категория: SQL Databases
Статус: Готово

## JOINS

Позволяют получать нам информацию из других таблиц.

Как можно увидеть по структуре, соединение бывает:

- внутренним INNER (по умолчанию)
- внешним OUTER, при этом внешнее соединение делится на левое LEFT, правое RIGHT и полное FULL

![image.png](image%20686.png)

![image.png](image%20687.png)

Semi-join - полусоединение, возвращает строки только одной из соединяемых таблиц, без выполнения соединения полностью. Анти-полусоединение возвращает те строки таблицы, которые не годятся для соединения с другой таблицей; т.е. они в обычном внешнем соединении выдавали бы NULL.

Пример semi-join:

![image.png](image%20688.png)

Подобным образом может использоваться анти-полусоединение для обработки подзапроса с NOT EXISTS.

### Разница между USING и ON

![image.png](image%20689.png)

Разница между JOIN ON и JOIN USING в SQL заключается в том, что ON позволяет указывать любое соответствие (разные имена колонок), а USING — это синтаксическая сокращённая версия для ситуации, когда имена столбцов совпадают.

С помощью ON можно присоединить не только колонку, но и набор колонок или даже целое условие. В то время как USING служит для указания списка столбцов, которые должны существовать в обеих таблицах. 

Ещё одно преимущество USING — при перечислении полей в запросе не обязательно указывать префикс. Если не перечислять поля явно, а использовать **`select *`** для соединения столбцов, то в результирующем наборе при **ON** колонка "всплывёт" дважды, в то время как с `USING` — только раз.

## Subquiries

Типы подзапросов

По количеству строк:

- Однострочные подзапросы
- Многострочные подзапросы

По виду:

- Многостолбцовые подзапросы
- Коррелированные подзапросы
- Вложенные подзапросы

Однострочные запросы могут находится в WHERE, HAVING, SELECT, ORDER 

![image.png](image%20690.png)

![image.png](image%20691.png)

Многострочные запросы

![image.png](image%20692.png)

### Использование ANY и ALL

С помощью оператора ALL мы можем сравнивать отдельное значение с каждым значением в наборе, полученным подзапросом. При этом данное условие вернёт TRUE, только если все сравнения отдельного значения со значениями в наборе вернут TRUE.

![image.png](image%20693.png)

Условное выражение с ANY имеет схожее поведение, но оно возвращает TRUE, если хотя бы одно сравнение отдельного значения со значением в наборе вернёт TRUE.

![image.png](image%20694.png)

### Многостолбцовые запросы

![image.png](image%20695.png)

### **Коррелированные подзапросы**

Все предыдущие рассматриваемые подзапросы были некоррелированные (независимые). Они могли выполняться автономно от основного запроса и мы могли посмотреть, что они возвращают перед тем, как их результат будет использоваться в основном запросе. Коррелированные же подзапросы ссылаются на один или несколько столбцов основного запроса.

![image.png](image%20696.png)

При написании вложенных подзапросов максимальный уровень вложенности - до 255.

## UNIONS

Позволяет объединять результаты выполнения SQL запросов.

![image.png](image%20697.png)

UNION по умолчанию убирает повторения в результирующей таблице. Для отображения с повторением есть необязательный параметр ALL.

Для корректной работы UNION нужно, чтобы результирующие таблицы каждого из SQL запросов имели одинаковое число столбцов, с одним и тем же типом данных и в той же самой последовательности.

Существует два других оператора, чьё поведение крайне схоже с UNION:

- INTERSECT Комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые имеют совпадения во втором элементе SELECT.
- EXCEPT Комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые не имеют совпадения во втором элементе SELECT.

Пример union xd

![image.png](image%20698.png)

## CTE vs inlined subqueries

Обобщённое табличное выражение или CTE (Common Table Expressions) - это временный результирующий набор данных, к которому можно обращаться в последующих запросах. Для написания обобщённого табличного выражения используется оператор WITH.

![image.png](image%20699.png)

Выражение с WITH считается «временным», потому что результат не сохраняется где-либо на постоянной основе в схеме базы данных, а действует как временное представление, которое существует только на время выполнения запроса, то есть оно доступно только во время выполнения операторов SELECT, INSERT, UPDATE, DELETE или MERGE.

Важное отличие между ними - CTE умеет в рекурсивность (что можно применять для древовидным структур):

CTE также могут быть использованы для выполнения рекурсивных запросов, которые позволяют итеративно обрабатывать данные, например, для работы с иерархическими структурами данных, такими как «руководитель — подчинённый».

![image.png](image%20700.png)

Еще один плюс немного большая производительность - в некоторых случаях могут незначительно снижать производительность, особенно в сложных запросах с большими объемами данных. 

CTE выполняются после запроса.