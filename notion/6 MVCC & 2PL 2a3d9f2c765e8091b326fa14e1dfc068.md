# 6. MVCC & 2PL

Категория: SQL Databases
Статус: Готово

## Что такое MVCC и 2PL?

MVCC и 2PL — это два разных механизма управления параллелизмом в базах данных, которые отличаются подходом к блокировкам и одновременному доступу к данным.

- MVCC (Multi-Version Concurrency Control) — это **многоверсионный контроль**, который позволяет транзакциям читать данные, не блокируя друг друга, путем создания новых версий записей вместо изменения существующих.
- 2PL (Two-Phase Locking) — это **протокол двухфазной блокировки**, который управляет доступом к данным с помощью блокировок, разделяя работу на фазу "расширения" (получение блокировок) и "сжатия" (освобождение блокировок), чтобы гарантировать сериализуемость транзакций.

### **MVCC в PostgreSQL**

- **Принцип работы**: Вместо блокировки данных, MVCC создает новую версию строки при изменении. Каждая транзакция работает со своей версией данных, что позволяет избежать блокировок при чтении.
- **Производительность**: MVCC повышает производительность за счет того, что операции чтения не блокируют операции записи, и наоборот.
- **Изоляция**: MVCC обеспечивает изоляцию транзакций, позволяя им не мешать друг другу, даже если они работают с одними и теми же данными одновременно.

### **Двухфазная блокировка (2PL)**

- **Принцип работы**: 2PL использует блокировки для обеспечения согласованности данных. Транзакция сначала запрашивает все необходимые блокировки, а затем применяет изменения.
- **Конкуренция**: 2PL может страдать от конкуренции за блокировки, так как транзакции, которые пытаются получить доступ к заблокированным данным, должны ждать, пока другие транзакции их освободят.
- **Производительность**: На высококонкурентных системах 2PL может снижать производительность, в отличие от MVCC.

### Snapshots (Снимки)

Изоляция в PostgreSQL строится на основе снимков данных (snapshot): каждая транзакция работает со своим снимком данных, который «содержит» данные, которые были зафиксированы до момента создания снимка, и не «содержит» еще не зафиксированные на этот момент данные.

На уровне изоляции Read Committed снимок создается в начале каждого оператора транзакции. Такой снимок активен, пока выполняется оператор:

![image.png](image%20562.png)

На уровнях Repeatable Read и Serializable снимок создается один раз в начале первого оператора транзакции. Такой снимок остается активным до самого конца транзакции:

![image.png](image%20563.png)

Снимок данных определяется несколькими параметрами:

- моментом создания снимка, а именно, номером следующей, еще не существующей в системе, транзакции (**snapshot.xmax**);
- списком активных транзакций на момент создания снимка (**snapshot.xip**).

Для удобства и оптимизации отдельно сохраняется и номер самой ранней из активных транзакций (**snapshot.xmin**):

![image.png](image%20564.png)

### **Горизонт событий**

Номер самой ранней из активных транзакций (snapshot.xmin) имеет важный смысл — он определяет «горизонт событий» транзакции. А именно, за своим горизонтом транзакция всегда видит только актуальные версии строк. За «горизонтом» все транзакции уже гарантированно завершились.

### VACUUM

`VACUUM` играет роль сборщика мусора для MVCC (Multi-Version Concurrency Control), поскольку удаляет устаревшие ("мертвые") строки, накапливающиеся из-за создания новых версий записей при изменениях. Это предотвращает раздувание базы данных (bloat), освобождает место на диске и поддерживает производительность запросов. 

Причины использовать VACUUM:

1. **Сбор мусора:** удаленные или устаревшие строки все еще занимают место на диске.
2. **Обновление статистики:** если статистика не обновлена, оптимизатор запросов начинает вести себя, как водитель без навигатора — блуждает в потёмках.
3. **Предотвращение переполнения xid:** старые транзакции могут привести к переполнению транзакционных идентификаторов (xid).

Виды VACUUM:

1. **VACUUM:** удаляет мусорные строки, но не возвращает место в ОС.
2. **VACUUM FULL:** полностью реорганизует таблицу, возвращает место в ОС, но блокирует доступ к таблице.
3. **AUTOVACUUM:** фоновый процесс, который автоматически запускает VACUUM, чтобы не приходилось делать это вручную.

### Разница между VACUUM и VACUUM FULL

Обычный `VACUUM` (без `FULL`) просто освобождает место и делает его доступным для повторного использования. Эта форма команды может работать параллельно с обычным чтением и записью в таблицу, так как эксклюзивная блокировка не требуется. Однако дополнительное место не возвращается операционной системе (в большинстве случаев); оно просто остается доступным для повторного использования в той же таблице. 

`VACUUM FULL` перезаписывает все содержимое таблицы в новый файл на диске без дополнительного места, позволяя вернуть неиспользуемое место операционной системе. Эта форма намного медленнее и требует `ACCESS EXCLUSIVE` блокировки каждой таблицы во время обработки.

### Heap Only Tuples

Postgresql отличается от других СУБД тем, что в ней при операции UPDATE, изменений в существующей строке не происходит, а вместо этого делается копия строки, которая отличается от оригинала значениями колонок, затронутых апдейтом — в оригинале они старые, а в копии — изменённые. 

Этот подход с одной стороны позволяет избежать блокировок при одновременном выполнении запросов на чтение и запись, а с другой стороны порождает необходимость постоянно вычищать старые версии строк, которые уже никто и никогда не прочитает. 

В связи с этой архитектурной фичей нередко возникает вопрос, что будет, если нужно хранить в БД что-то вроде времени последнего доступа к данным, которые в остальном не меняются. Не отзовётся ли это на производительности? Не приведёт ли к постоянной перестройке индексов?

Если коротко, то да, Copy On Write никуда не денется, но индексы во многих случаях можно будет не перестраивать, благодаря HOT.

Heap only tuples, также известные как HOT, - это оптимизация, которую использует Postgres для того, чтобы уменьшить количество I/O необходимого для апдейтов. 

Из-за MVCC апдейт в Postgres состоит из поиска строки для апдейта и вставки новых версий строки в базу данных. Основной недостаток этой процедуры — нужда в повторном добавлении строки в каждый индекс.

Чтобы уменьшить количество I/O необходимого для UPDATE, команда Postgres добавила в Postgres HOT. 

При апдейте строки Postgres поставит новую копию строки сразу после старой копии строки. Плюс в старой копии строки проставляется специальная метка, для того чтобы Postgres знал, что новая копия строки находится сразу после старой. Поэтому обновлять все индексы не нужно.

Во время скана по индексу для которого новая копия строки проходит фильтр Postrges найдёт старую копию строки. Так как на старой копии строки стоит специальная метка, Postgres поймёт, что новая копия строки находится сразу после старой и найдёт новую версию и использует именно её. Получается, что Postgres в таких случаях может вести себя так, как будто все индексы указывают на новую копию строки, и перестраивать их не нужно.

Сейчас HOT задействован только тогда, когда в апдейте участвуют только не индексируемые столбцы. Если хотя бы один столбец, участвующий в апдейте входит в индекс, HOT применить нельзя. 

В этом случае с применением HOT есть несколько проблем. Например, когда по индексу на колонке, которую проапдейтили нужно сделать индекс скан и старая копия строки попадает в предикат скана, а новая — нет. 

В этой ситуации, Postgres попробует использовать индекс, чтобы быстро найти все строки, которые подходят для предиката запроса, и в случае столбцов, которые проапдейтили с помощью HOT, выдаст новую копию строки, которая предикату запроса не подходит. Благодаря этому ограничению (что HOT не работает когда в апдейт включены индексируемые колонки), Постгрес может дать гарантию, что когда он пытается найти строки, которые подходят для предиката, через который пропускают индекс, то если предикату подходит старая версия строки, то новая версия строки ему тоже подходит и наоборот.

В данный момент в разработке находится расширение HOT под названием WARM, которое работает и при апдейте столбцов, на которых созданы индексы. Идея за WARM в том, чтобы ставить новую строку сразу за старой и обновлять строку для индексов, в которых были изменённые столбцы. Это значительно осложняет описанную ситуацию, потому что теперь Постгресу нужен способ каким-то образом определить проходит ли строка фильтр для индекса, или нет.

P.S. Heap only tuple это как раз новая версия строки. Heap — это как ни странно — таблица, а Heap only означает, что эту строку можно найти только по цепочке, которая ведёт от старшей версии строки, которая называется корневой.

### Index bloat

"Index bloat" в PostgreSQL — это **ситуация, когда индекс занимает значительно больше места на диске, чем требуется для хранения фактических данных, из-за накопления "мертвых" версий строк после операций** `UPDATE` и `DELETE`. 

Это происходит из-за механизма MVCC, который оставляет старые версии строк, а не удаляет их сразу, что может привести к снижению производительности и увеличению потребления дискового пространства.

**Как возникает bloat**

- **Механизм MVCC**: PostgreSQL использует многоверсионность для обеспечения параллельного доступа к данным. При обновлении (`UPDATE`) старая версия строки помечается как "мертвая", а новая добавляется в другое место. При удалении (`DELETE`) старая строка просто помечается как "мертвая".
- **Пространство**: Эти "мертвые" версии занимают место в индексе, но не могут быть использованы для новых запросов.
- **Влияние**: Накопление такого неиспользуемого пространства приводит к увеличению размера индексов и снижению скорости их работы.

**Как бороться с bloat**

- [**VACUUM**](https://www.google.com/search?client=opera&q=VACUUM&sourceid=opera&ie=UTF-8&oe=UTF-8&mstk=AUtExfDRlQQ6zOclKku7QpjBvqbBUq1cYPMctdof_2LaoYDc6yPhHvwzrjERvLTvp9Fw7ZuXWWOE_ZK0HBE2mjCBrBj_2LM9D6UKb7B9vYNR4FN_aiLK6QjMDWs2j6Q97iNj6k8E_rV_a_WdpfRtNwA--2D3W-Szga4-PVxjbI6mh3rQKVwo7Pghfl4EM3yVIkgsGC8aguYHHdZDtoA_tezJQIxJNAybNgflqkMXWAGbrxt9po9lAyqFhUGKfDGZZdF9zU_9lK61Vv7AjY75aUivsvwnJyQA59z25tniRAThfJeC7g&csui=3&ved=2ahUKEwix6Las-oCRAxWzCBAIHR0iDiAQgK4QegQIBRAB): Процесс `VACUUM` (особенно автовакуум) очищает "мертвые" строки и возвращает их в систему для повторного использования.
- [**REINDEX**](https://www.google.com/search?client=opera&q=REINDEX&sourceid=opera&ie=UTF-8&oe=UTF-8&mstk=AUtExfDRlQQ6zOclKku7QpjBvqbBUq1cYPMctdof_2LaoYDc6yPhHvwzrjERvLTvp9Fw7ZuXWWOE_ZK0HBE2mjCBrBj_2LM9D6UKb7B9vYNR4FN_aiLK6QjMDWs2j6Q97iNj6k8E_rV_a_WdpfRtNwA--2D3W-Szga4-PVxjbI6mh3rQKVwo7Pghfl4EM3yVIkgsGC8aguYHHdZDtoA_tezJQIxJNAybNgflqkMXWAGbrxt9po9lAyqFhUGKfDGZZdF9zU_9lK61Vv7AjY75aUivsvwnJyQA59z25tniRAThfJeC7g&csui=3&ved=2ahUKEwix6Las-oCRAxWzCBAIHR0iDiAQgK4QegQIBRAD): Команда `REINDEX` полностью перестраивает индекс, удаляя старую версию и создавая новую, очищенную. Она используется, когда индекс поврежден, но может помочь и с раздуванием, хотя это более ресурсоемкая операция, чем `VACUUM`.