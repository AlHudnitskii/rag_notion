# 19. GIL

Категория: Python Core
Статус: Готово

GIL (global interpreter lock) - это мьютекс, который блокирует доступ к объекту в многопоточных средах, разрешая лишь одному потоку выполнять байт-код Python в один момент времени. Благодаря GIL лишь один поток имеет доступ к интерпретатору Python в определенный момент времени.

Без GIL множество потоков могли бы одновременно изменять и взаимодействовать со списками или словарями, чтобы привело бы к непредсказуемому поведению и разнообразным гонкам данных.

Важно отметить, что GIL существует на уровне интерпретатора Python и не зависит от операционной системы. Поэтому, даже если ваша операционная система поддерживает многозадачность, GIL может ограничивать использование нескольких ядер процессора.

В случае когда несколько потоков пытаются изменить одни и те же данные, могут возникнуть гонки данных (race conditions).

![image.png](image%20195.png)

![image.png](image%20196.png)

В этом примере два потока пытаются инкрементировать общий счетчик. Вследствие блокировки GIL, результат этой операции может быть неопределенный и зависит от того, какой поток получит доступ к счетчику в данный момент.

Способы обхода GIL:

1. Использование модуля `multiprocessing`:

![image.png](image%20197.png)

1. Использование `concurrent.futures`: 

![image.png](image%20198.png)

1. Использование библиотеки `asyncio`:

![image.png](image%20199.png)

1. Использование С-расширений

**Почему GIL полезен?**

GIL полезен, потому что CPython увеличивает и уменьшает целые числа, которые могут быть разделены между потоками повсюду. Это способ CPython для сборки мусора. Каждый объект Python имеет счётчик ссылок, в котором подсчитывается количество других объектов, ссылающихся на этот объект. Когда количество ссылок достигает нуля, объект удаляется. Если бы не GIL, некоторые декременты могли бы перезаписать друг друга, и объект остался бы в памяти навсегда. Что еще хуже, несогласованные приращения счётчика ссылок могут привести к удалению ещё использующегося объекта.

GIL также упрощает реализацию встроенных изменяемых структур данных. Списки, словари и множества не используют блокировку, но благодаря GIL их можно безопасно использовать в многопоточных программах. Аналогично, GIL позволяет потокам безопасно получать доступ к глобальным данным и данным в масштабах интерпретатора: загруженным модулям, предварительно распределенным объектам и так далее.

**Многопроцессорность нужна для:**

- CPU-интенсивных задач (вычисления, обработка данных)
- Обход GIL — каждый процесс имеет свой интерпретатор и GIL
- Использование всех ядер процессора

![image.png](image%20200.png)

Так почему же GIL освобождается при вводе-выводе, но не освобождается для счетных задач? Все дело в системных вызовах, которые
выполняются за кулисами. В  случае ввода-вывода низкоуровневые
системные вызовы работают за пределами среды выполнения Python.
Это позволяет освободить GIL, потому что код операционной системы не взаимодействует напрямую с объектами Python. GIL захватывается снова, только когда полученные данные переносятся в объект
Python. Стало быть, на уровне ОС операции ввода-вывода выполняются конкурентно. Эта модель обеспечивает конкурентность, но не
параллелизм. В других языках, например Java или C++, на многоядерных машинах можно организовать истинный параллелизм, потому
что никакой GIL нет и код может выполняться строго одновременно.
Но в  Python лучшее, на что можно рассчитывать, – конкурентность
операций ввода-вывода, поскольку в  любой момент может выполняться только один кусок написанного на Python кода.