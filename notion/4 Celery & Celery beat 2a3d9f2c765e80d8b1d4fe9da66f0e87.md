# 4. Celery & Celery beat

Категория: Frameworks & Libraries
Статус: В процессе

### Celery

Celery - самый популярный инструмент для асинхронной обработки задач. Он позволяет выполнять задачи в фоновом режиме и гибко настраивать параметры для каждой задачи.

Создание асинхронной задачи начинается с определения функции, которая будет выполняться асинхронно. Для этого используется декоратор `@task`:

![image.png](image%20653.png)

Для запуска такой задачи есть три способа `apply_async`, `delay` и обычный вызов `call`.

1. `apply_async` - это метод, который предоставляет максимальную гибкость при запуске задачи и принимает большое количество [аргументов](https://docs.celeryq.dev/en/stable/reference/celery.app.task.html#celery.app.task.Task.apply_async).

![image.png](image%20654.png)

1. `delay` - в отличие от `apply_async` имеет ограниченный список принимаемых аргументов. Такой способ запуска мы рассматриваем, когда нужно просто запустить задачу без необходимости передавать именованные аргументы и другие параметры.

![image.png](image%20655.png)

1. Последний способ - это обычный вызов функции. В таком случае задача будет выполнена сразу же, а не назначена в очередь.

![image.png](image%20656.png)

Еще способы

- `chain()` позволяет соединить несколько задач в одну последовательность, где результат одной задачи передается в качестве аргумента следующей:

![image.png](image%20657.png)

- `group()` используется для параллельного выполнения набора задач. Он возвращает специальный объект `GroupResult`, который позволяет отслеживать выполнение группы задач

![image.png](image%20658.png)

- `chord()` — это комбинация `group()` и `chain()`, позволяющая выполнить группу задач параллельно и затем вызвать callback-задачу с результатами группы:

![image.png](image%20659.png)

Пример взаимодействия с Celery на уровне архитектуры

![image.png](image%20660.png)

Для работы с Celery в директории config нужно добавить файл `celery.py`:

![image.png](image%20661.png)

А в __**init**__.py прописать следующее, чтобы Celery автоматически импортировалось при запуске Django:

![image.png](image%20662.png)

### Celery Beat

**Celery Beat**  - это ****планировщик, запускающий задачи с установленными интервалами. Эти задачи затем выполняются доступными рабочими узлами.

**Основные компоненты:**

1. **Планировщик (Scheduler)**: Этот компонент отвечает за управление периодическими задачами. Он проверяет расписание и отправляет задачи в очередь в нужное время.
2. **Рабочие узлы (Worker Nodes)**: Эти узлы забирают задачи из очереди и выполняют их. Каждый узел может обрабатывать множество задач параллельно, что позволяет эффективно использовать ресурсы системы.
3. **Посредник (Broker)**: Для этой роли обычно используют RabbitMQ или Redis. Они используются для передачи сообщений между планировщиком и рабочими узлами. Брокер берет на себя доставку сообщений и управление очередями.

Чтобы периодически вызвать задачу, необходимо добавить запись в расписания ударов.

По умолчанию записи берутся из настройки [**`beat_schedule`**](https://django.fun/docs/celery/5.1/userguide/configuration/#std-setting-beat_schedule), но можно использовать и пользовательские хранилища, например, хранить записи в базе данных SQL.

![image.png](image%20663.png)

Функция [**`add_periodic_task()`**](https://django.fun/docs/celery/5.1/reference/celery/#celery.Celery.add_periodic_task) добавит запись в настройку [**`beat_schedule`**](https://django.fun/docs/celery/5.1/userguide/configuration/#std-setting-beat_schedule) за кадром, и эту же настройку можно использовать для установки периодических заданий вручную:

![image.png](image%20664.png)

Можно использовать timedelta, чтобы указать интервал, через который будет выполняться задача.

![image.png](image%20665.png)

Если вы хотите больше контролировать время выполнения задания, например, определенное время суток или день недели, вы можете использовать тип расписания [**`crontab`**](https://django.fun/docs/celery/5.1/reference/celery.schedules/#celery.schedules.crontab):

![image.png](image%20666.png)

Примеры использования[**`crontab`**](https://django.fun/docs/celery/5.1/reference/celery.schedules/#celery.schedules.crontab):

| **`crontab()`** | Выполняйте каждую минуту. |
| --- | --- |
| **crontab(minute=0, hour=0)** | Выполнять ежедневно в полночь. |
| crontab(minute=0, hour='*/3') | Выполнять каждые три часа: полночь, 3 утра, 6 утра, 9 утра, полдень, 3 вечера, 6 вечера, 9 вечера. |
| crontab(minute='*/15') | Выполняется каждые 15 минут. |
| crontab(0, 0,month_of_year='*/3') | Выполнять каждый день в первый месяц каждого квартала. |

### Запуск планировщика

У нас есть возможность использовать две разных команды:

1. `celery -A celery_app worker -B --loglevel=INFO`
2. `celery -A celery_app beat --loglevel=INFO`

Первая команда запускает **рабочий узел**, который одновременно будет являться и **планировщиком**. Эта команда лучше всего подходит **для** **отладки** и не рекомендуется для запуска в production среде. Дело в том, что в этом случае на работу планировщика могут повлиять выполняемые задачи, что может привести к сбоям.

Вторая команда запускает только **планировщик**. В таком случае он занимается только назначением задач в нужную очередь и не занимается выполнением задач. Такая схема работы более надёжна. Для того, чтобы задачи начали выполняться, нам понадобится запустить **worker** отдельно.

Сам рабочий узел мы будем запускать с помощью команды:

`celery -A celery_app worker`

**Что если выполнение задач занимает разное время и нужно выполнить их все?**

Здесь на помощь приходит параметр **autoscale.**

Если задачи имеют разное время выполнения и невозможно точно предсказать нагрузку, то автоматическое масштабирование может помочь. Здесь всё будет ограничено количеством ядер. Цифру больше числа доступных ядер указывать нет смысла.

Вот пример, как указать масштабирование в настройках:

![image.png](image%20667.png)

![image.png](image%20668.png)

**Как лучше всего отслеживать выполнение периодических задач?**

Лучший инструмент для мониторинга выполнения периодических задач для Celery - это [Flower](https://github.com/mher/flower). Он легко подключается и дает очень подробную статистику по всем задачам. 

Вот так выглядит интерфейс:

![image.png](image%20669.png)

Второй способ - использование `app.control.inspect()`. С помощью него можно получить доступ к подробной информации о задачах прямо из кода.
Методы `app.control.inspect()` :

![image.png](image%20670.png)

![image.png](image%20671.png)