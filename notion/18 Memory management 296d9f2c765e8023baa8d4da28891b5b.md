# 18. Memory management

Категория: Python Core
Статус: В процессе

Стандартный интерпретатор питона (CPython) использует сразу два алгоритма, подсчет ссылок и generational garbage collector (далее GC), более известный как стандартный [модуль gc](https://docs.python.org/3.6/library/gc.html) из Python.

**1. Механизм подсчёта ссылок (Reference Counting)
В CPython все объекты представлены структурой** `PyObject`:

**Каждый объект Python содержит:**

1. **Счётчик ссылок** (`ob_refcount`) - количество ссылок на объект
2. **Информация о типе** (`ob_type`) - указатель на тип объекта
3. **Ваши данные** - само значение объекта

![image.png](image%2092.png)

**Reference Count** отслеживает, сколько переменных указывают на объект. Когда счетчик достигается нуля, память освобождается.

Количество ссылок на объект можно получить, используя функцию sys.getrefcount().

### Работа подсчета ссылок

![image.png](image%2093.png)

### Размер основных объектов в Python

![image.png](image%2094.png)

### Способы проверить количество ссылок на объект

![image.png](image%2095.png)

### Плюсы и минусы алгоритма подсчета ссылок

Плюсы:

- **Простота реализации** - легко понять и реализовать
- **Детерминированность** - объект удаляется сразу при refcount=0
- **Предсказуемость** - можно точно знать, когда освободится память
- **Низкие накладные расходы** - работает постоянно, без пауз

Минусы:

- **Циклические ссылки** - не может обнаружить и удалить
- **Накладные расходы на каждую операцию** - постоянное обновление счётчиков
- **Дополнительная память** - каждый объект хранит счётчик
- **Проблемы с многопоточностью** - требуется синхронизация (GIL)

### Как создаётся переменная в Python

![image.png](image%2096.png)

### Garbage Collector (Сборщик мусора)

GC - автоматический механизм управления памятью, который освобождает память, занятую объектами, которые больше не используются программой.

Решение проблемы циклических ссылок

![image.png](image%2097.png)

![image.png](image%2098.png)

Сам модуль GC

![image.png](image%2099.png)

**GC отслеживает только контейнерные типы**, которые могут содержать ссылки на другие объекты: list, dict, set, tuple (если содержит изменяемые объекты), object() (пользовательские классы).

### *Три поколения GC*

![image.png](image%20100.png)

![image.png](image%20101.png)

![image.png](image%20102.png)

### Как узнать пороги запуска GC

**Пороги (thresholds)** определяют, когда запускается сборка мусора для каждого поколения.

Узнать об этом можно, используя метод `gc.get_threshold()`.

![image.png](image%20103.png)

![image.png](image%20104.png)

Изменить порог запуска GC можно, используя метод  `gc.set_threshold()`.

![image.png](image%20105.png)

### Рекомендации по использованию GC:

Включать:

1. Работает по умолчанию и делает это хорошо для большинства приложений.
2. Работа с циклическими ссылками.

Выключать:

1. В критичных по производительности секциях.
2. В real-time приложениях.
3. В серверных приложениях с предсказуемой нагрузкой.