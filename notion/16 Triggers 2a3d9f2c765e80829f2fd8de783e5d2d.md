# 16. Triggers

Категория: SQL Databases
Статус: Готово

Триггер - указание, согласно которому PostgreSQL должен автоматически вызывать определенную функцию при каждом выполнении операции указанного типа. Триггеры можно прикреплять к таблицам, представлениям и внешним таблицам.

1. Для таблиц и внешних таблиц можно определить триггеры, которые будут выполняться до или после любой операции `INSERT`, `UPDATE` или `DELETE` , либо один раз для каждой измененной строки, либо один раз для каждого оператора SQL. Триггеры также могут срабатывать для операторов `TRUNCATE`. 
2. В представлениях можно определить триггеры для выполнения вместо операций  `INSERT`, `UPDATE` или `DELETE` .  Триггеры `INSTEAD OF` срабатывают один раз для каждой строки представления, которую необходимо изменить (могут работать только при FOR EACH ROW). Триггеры представлений также можно определить для выполнения до или после операций `INSERT`, `UPDATE` или `DELETE`. Однако эти триггеры срабатывают только в том случае, если в представлении также есть триггер `INSTEAD OF`.

Если происходит событие триггера, для обработки этого события вызывается функция триггера. Триггерные функции могут быть написаны на большинстве доступных процедурных языков, включая [PL/pgSQL](https://www.postgresql.org/docs/16/plpgsql.html), [PL/Tcl](https://www.postgresql.org/docs/16/pltcl.html), [PL/Perl](https://www.postgresql.org/docs/16/plperl.html) и [PL/Python](https://www.postgresql.org/docs/16/plpython.html).

### Триггеры уровня строки и уровня оператора

PostgreSQL позволяет создавать триггеры для каждой строки или для каждого оператора. При использовании триггера для каждой строки PostgreSQL вызывает триггерную функцию один раз для строки, которую обрабатывает оператор, запускающий триггер.

PostgreSQL вызывает триггер для каждого оператора только один раз, когда выполняется соответствующий оператор, независимо от количества строк, которые обрабатывает этот оператор. Если оператор изменяет ноль строк, он также вызывает срабатывание триггера.

Эти два типа триггеров называются **триггерами уровня строки** (FOR EACH ROW) и **триггерами уровня оператора  (FOR EACH STATEMENT)** соответственно. Триггеры для оператора `TRUNCATE` можно определить только на уровне оператора, а не на уровне строки.

### **Триггеры BEFORE, AFTER и INSTEAD OF**

Триггеры классифицируются в зависимости от того, срабатывают ли они до, после или вместо операции. 

Триггеры `BEFORE` на уровне оператора срабатывают до того, как оператор начнет что-либо делать, триггеры `AFTER` на уровне оператора срабатывают в конце оператора. Эти типы триггеров могут быть определены для таблиц, представлений или внешних таблиц.

Триггеры `BEFORE` на уровне строки срабатывают перед обработкой конкретной строки, триггеры `AFTER` на уровне строки срабатывают в конце оператора, но до срабатывания любого триггера `AFTER` на уровне оператора. Эти типы триггеров не рекомендуется использовать с представлениями.
Триггеры `INSTEAD OF` можно определять только в представлениях и только на уровне строк. Они срабатывают, как только строка представления определяется как подлежащая обработке.

Обычно триггеры `BEFORE` на уровне строки используются для проверки или изменения данных, которые будут вставлены или обновлены. Например, триггер `BEFORE` можно использовать для вставки текущего времени в столбец типа `timestamp` или для проверки согласованности двух элементов строки. Триггеры `AFTER` на уровне строк эффективны для каскадного обновления других таблиц или проверки соответствия внесенных изменений данным в других таблицах.

Триггер `AFTER` может получить доступ к конечному значению строки, а триггер `BEFORE` — нет, поскольку могут существовать другие триггеры `BEFORE`, которые сработают позже. Если нет особых причин для выбора между триггерами `BEFORE` или `AFTER`, триггер `BEFORE` предпочтительнее, поскольку он не требует, чтобы информация об операции сохранялась до конца оператора.

### Операции с триггерами

1. Создание триггера 

Для создания нового триггера необходимо создать триггерную функцию, после чего использовать оператор  [CREATE TRIGGER](https://www.postgresql.org/docs/16/sql-createtrigger.html), чтобы привязать триггерную функцию к отношению.

![image.png](image%20534.png)

Когда функция PL/pgSQL вызывается триггером изменения данных, в блоке верхнего уровня автоматически создается несколько специальных переменных. Они перечислены в таблице ниже. 

![image.png](image%20535.png)

Возвращаемые типы данных для триггерных функций:

**RETURN NULL**:

- для триггерных функций c AFTER, возвращаемые значения игнорируются;
- если функция, выполняемая до операции со строкой (BEFORE), возвращает NULL, то такая строка пропускается. Операция по изменению, обновлению или удалению с ней не выполняется. При этом выполнение транзакции не прерывается.

**RETURN OLD**. Триггерные функции, выполняемые до (BEFORE) операции DELETE, должны возвращать исходную строку (OLD), если операцию удаления со строкой нужно выполнить. Если же ее нужно пропустить, возвращается NULL.

**RETURN NEW**. Функции c BEFORE операции INSERT или UPDATE, должны возвращать новую или обновленную строку, которая будет добавлена в таблицу.

1. Изменение триггера

Для изменения триггера используется команда [ALTER TRIGGER](https://www.postgresql.org/docs/16/sql-altertrigger.html):

![image.png](image%20536.png)

1. Отключение/Подключение триггера

Чтобы временно отключить или подключить триггер, вызовите команду [ALTER TABLE](https://www.postgresql.org/docs/16/sql-altertable.html) как показано ниже.
Отключение триггера:

![image.png](image%20537.png)

Подключение триггера:

![image.png](image%20538.png)

1. Удаление триггера

Чтобы удалить триггер, используйте команду [DROP TRIGGER](https://www.postgresql.org/docs/16/sql-droptrigger.html):

![image.png](image%20539.png)

1. Отображение списка триггеров

Для вывода списка всех триггеров в текущей базе данных, используйте системное представление `information_schema.triggers`:

![image.png](image%20540.png)

### Особенности поведения триггеров

1. Триггер AFTER

Выполнение триггера `AFTER` может быть отложено до конца транзакции, а не до конца оператора, если триггер был определен как `CONSTRAINT`.

 2. Возвращаемые значения триггерных функций

Функции, вызываемые триггерами уровня операторов, должны возвращать `NULL`. Триггерные функции, вызываемые триггерами уровня строки, могут возвращать строку таблицы.

1. Порядок срабатывания триггеров

Если для одного и того же события в одном отношении определено более одного триггера, триггеры сработают в алфавитном порядке по имени триггера. В случае триггеров `BEFORE` и `INSTEAD OF` строка, возвращаемая каждым триггером, становится входными данными для следующего триггера. Если какой-либо триггер `BEFORE` или `INSTEAD OF` возвращает `NULL`, операция останавливается и последующие триггеры для этой строки не срабатывают.

 4. Условие триггера WHEN 
Определение триггера также может содержать логическое условие `WHEN`, которое проверяет, должен ли срабатывать триггер. В триггерах уровня строки условие `WHEN` может проверять старые и новые значения столбцов строк. 

5. Триггер без привязки к таблице

Создать триггер без привязки к таблице нельзя. Триггер всегда привязан к конкретной таблице или представлению (VIEW). 
Однако есть **EVENT TRIGGERS** - это триггеры уровня базы данных, которые срабатывают на DDL (Data Definition Language)-операции:

![image.png](image%20541.png)

1. Исключение в триггере

В триггерах можно и нужно создавать исключения. RAISE EXCEPTION отменяет всю транзакцию.

![image.png](image%20542.png)

1. Обязательность ли возврата значения

Триггерная функция ВСЕГДА должна возвращать:

- **BEFORE ROW триггер:**
    - `RETURN NEW` - продолжить операцию с (возможно измененной) строкой
    - `RETURN OLD` - вернуть исходную строку (для UPDATE)
    - `RETURN NULL` - отменить операцию для этой строки
- **AFTER ROW триггер:**
    - Возвращаемое значение игнорируется, но вернуть что-то нужно (обычно NULL)
- **STATEMENT триггер:**
    - Всегда возвращает NULL
1. INSERT-операция внутри INSERT-триггера

**Технически возможно, но ОПАСНО** - можно создать бесконечную рекурсию!

PostgreSQL по умолчанию защищает от бесконечной рекурсии (ограничение глубины стека), но лучше избегать:

![image.png](image%20543.png)