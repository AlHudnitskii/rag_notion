# 5. API Design

Категория: Web & Networks
Статус: Готово

## REST

Rest (REpresentational State Transfer) - архитектурный стиль, созданный Роем Филдингом. Чтобы сервис стал RESTful сервис должен соблюдать ограничения, указанные в диссертации Роя Филдинга. В современном мире RESTful почти всегда означает API на основе HTTP. Это означает, что он работает в режиме запрос-ответ по протоколу HTTP, обычно используя JSON в качестве формата данных в текстах запросов и ответов

### Шесть ограничений RESTful

Чтобы API считалось RESTful на него должны накладываться шесть ограничений:

1. **Единый интерфейс (Uniform Interface)**

![image.png](image%20349.png)

Данное ограничение определяет интерфейс между клиентами и серверами. Оно упрощает и разъединяет архитектуру, что позволяет каждой части развиваться независимо. Четырьмя руководящими принципами единого интерфейса являются:

1.a На основе ресурсов

Отдельные ресурсы идентифицируются в запросах с использованием URI в качестве идентификаторов ресурсов. Сами ресурсы концептуально отделены от представлений, которые возвращаются клиенту.

1.b Манипулирование ресурсами с помощью представлений

Когда клиент хранит представление ресурса, включая любые прикрепленные к нему метаданные, у него достаточно информации для изменения или удаления ресурса на сервере, при условии, что у него есть на это разрешение.

1.с Сообщения с описанием о себе

Каждое сообщение содержит достаточно информации, чтобы описать, как обработать сообщение.

1.d Hypermedia as the Engine of Application State (HATEOAS)
Клиенты передают состояние с помощью содержимого основной части, параметров строки запроса, заголовков запроса и запрашиваемого URI. Сервисы передают состояние клиентам с помощью содержимого основной части, кодов ответов и заголовков ответов. 

1. **Без сохранения состояния (Stateless)**

Это означает, что состояние, необходимое для обработки запроса, содержится в самом запросе, будь то как часть URI, параметров строки запроса, тела или заголовков. URI однозначно идентифицирует ресурс, а текст содержит состояние (или изменение состояния) этого ресурса. Затем, после того как сервер выполнит его обработку, соответствующее состояние или часть(ы) состояния, которые имеют значение, передаются обратно клиенту через заголовки, статус и текст ответа.

1. **Кэшируемость (Cacheable)**

Ответы сервера могут быть помечены как кэшируемые, позволяя клиенту или промежуточному прокси-серверу использовать сохраненные данные для последующих запросов. Это повышает производительность и снижает нагрузку на сервер.

1. **Клиент-Сервер (Client-Server)**

Клиент и сервер полностью независимы друг от друга. Это позволяет клиенту и серверу развиваться по отдельности, улучшая управляемость и масштабируемость.

1. **Многоуровневая система (Layered System)**

Клиент обычно не может определить, подключен ли он непосредственно к конечному серверу или к промежуточному по пути. Промежуточные серверы могут повысить масштабируемость системы, позволяя распределять нагрузку и предоставляя общие кэши. Уровни также могут обеспечивать соблюдение политик безопасности.

1. **Код по запросу (Code on Demand)**

Серверы могут временно расширять или настраивать функциональность клиента, передавая ему логику, которую он может выполнять. Примерами этого могут служить клиентские скрипты, такие как JavaScript.

### Использование HTTP методов для запросов

![image.png](image%20350.png)

Важно: GET-запросы не должны изменять какие-либо базовые данные ресурса. Измерения и отслеживание того, какие данные обновляются, все еще могут выполняться, но ресурс, идентифицируемый URI, не должен изменяться.

### Правила написания URLS в RESTful API

В RESTful URL должны использовать существительные во множественном числе для идентификации ресурсов, избегая глаголов и других форм.

Правильно: `/users`, `/products` ,  `/users/123/orders`

Неправильно: `/user` ,`/getUsers`, `/createProduct`

## GraphQL

![image.png](image%20351.png)

![image.png](image%20352.png)

![image.png](image%20353.png)

Типы запросов в GraphQL:

- query

![image.png](image%20354.png)

![image.png](image%20355.png)

![image.png](image%20356.png)

- mutation

![image.png](image%20357.png)

![image.png](image%20358.png)

![image.png](image%20359.png)

- subscription

![image.png](image%20360.png)

![image.png](image%20361.png)

![image.png](image%20362.png)

### Фрагменты в GraphQL

![image.png](image%20363.png)

![image.png](image%20364.png)

### Директивы в GraphQL

![image.png](image%20365.png)

### Схемы в GraphQL

![image.png](image%20366.png)

![image.png](image%20367.png)

GraphQL поддерживает 4 типа данных:

- String
- Int
- Float
- Boolean

### **Зачем нужен GraphQL**

- **Оптимизация трафика:** Клиент запрашивает только те данные, которые ему нужны, что особенно важно для мобильных приложений с медленным интернетом.
- **Гибкость:** Клиент сам решает, какую структуру данных получить, а не получает фиксированный набор, как в REST.
- **Единый эндпоинт:** Вместо множества URL, как в REST, все запросы идут на один эндпоинт.
- **Минимизация запросов:** Получение связанных данных из нескольких источников в одном запросе, что экономит время и ресурсы.
- **Автоматическая документация:** Типизированная схема API делает его самодокументируемым.

### **Плюсы GraphQL**

- **Гибкость запросов:** Клиент может точно указать, какие поля ему нужны.
- **Оптимизация сетевого трафика:** Отсутствует передача лишних данных.
- **Единый эндпоинт:** Упрощает управление API.
- **Совместимость:** Позволяет легко объединять данные из разных источников в одном запросе.
- **Снижение количества запросов:** Получение связанных данных одним запросом.

### **Минусы GraphQL**

- **Сложность:** Может быть сложнее в настройке и реализации, чем REST, особенно для новичков.
- **Кэширование:** В отличие от REST, GraphQL не имеет встроенного механизма кэширования, хотя его можно реализовать с помощью сторонних инструментов.
- **Обработка ошибок:** Ошибки возвращаются в теле ответа, а не с помощью стандартных HTTP-кодов.
- **Загрузка файлов:** Не имеет встроенной поддержки загрузки файлов; требует дополнительных решений.

## gRPC

gRPC — это фреймворк для вызова процедур с открытым исходным кодом, который использует HTTP/2 для передачи данных в двоичном формате протоколов [Protobuf](https://www.google.com/search?q=Protobuf&client=opera&hs=ITD&sca_esv=3fb0e2d94fbc189e&sxsrf=AE3TifN4E07ViaNs0mxDLwKpB9ka_qnHgg%3A1764772317082&ei=3UkwaerdBO6rxc8P24iPiAs&ved=2ahUKEwjVqfab0aGRAxWLRfEDHS0cM3kQgK4QegQIARAC&uact=5&oq=gRPC+%D1%87%D1%82%D0%BE+%D1%82%D0%B0%D0%BA%D0%BE%D0%B5+%D0%BF%D0%BB%D1%8E%D1%81%D1%8B+%D0%B8+%D0%BC%D0%B8%D0%BD%D1%83%D1%81%D1%8B+%D0%B8+%D0%B7%D0%B0%D1%87%D0%B5%D0%BC+%D0%BD%D1%83%D0%B6%D0%B5%D0%BD+%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0+%D0%BC%D0%B5%D0%B6%D0%B4%D1%83+%D0%BD%D0%B8%D0%BC+%D0%B8+rest+api&gs_lp=Egxnd3Mtd2l6LXNlcnAid2dSUEMg0YfRgtC-INGC0LDQutC-0LUg0L_Qu9GO0YHRiyDQuCDQvNC40L3Rg9GB0Ysg0Lgg0LfQsNGH0LXQvCDQvdGD0LbQtdC9INGA0LDQt9C90LjRhtCwINC80LXQttC00YMg0L3QuNC8INC4IHJlc3QgYXBpSABQAFgAcAB4AZABAJgBAKABAKoBALgBA8gBAPgBAZgCAKACAJgDAJIHAKAHALIHALgHAMIHAMgHAA&sclient=gws-wiz-serp&mstk=AUtExfDLwV1GTj0gugan7Jl_qN5Rl60vvZahp7RgzwdMgZiUuVgsikxLKJhfVCJQ9GMtVuMCluSAcsycbs7WjJCo6PgQTe4hMJ2ZU-DKefIYOldkZMCX7M3g-xDdIlsVrt2_DK0QMDZeGrgCjCkPTnRnBD6GbSZdEbLGQoE-zuLA5SZZx86RkNyQlzv23-3JynLoFww_FCoxKcJGJmFgo_Mc7CmW3bmjwpNp9v5Xsg2WDawFzcmJ5ikOoKcXWXSJrg7F5kqWTuCcQPTp58kEYyoMGjVJ&csui=3), что обеспечивает высокую производительность для внутреннего взаимодействия между микросервисами, потоковой передачи данных и работы с большими объёмами информации. В отличие от REST, gRPC имеет более строгую контрактную модель, что делает его менее удобным для общедоступных API, но более эффективным для высоконагруженных систем, где важна скорость и низкие задержки. 

Protobuf (Protocol Buffers) — это **язык-независимый и платформенно-независимый механизм сериализации структурированных данных, разработанный Google**. Он представляет собой компактный бинарный формат, который используется для эффективного обмена данными между приложениями, например, при работе с микросервисами или в рамках gRPC

![image.png](image%20368.png)

![image.png](image%20369.png)

![image.png](image%20370.png)

### **Плюсы gRPC**

- **Высокая производительность:** Использование HTTP/2 и двоичного формата `Protobuf` значительно уменьшает задержки и объём передаваемого трафика.
- **Поддержка потоковой передачи:** Полностью поддерживает двунаправленную потоковую передачу данных, что важно для приложений реального времени.
- **Строгие контракты:** Использование `Protobuf` позволяет создавать контракты (схемы) API, которые обеспечивают явное и строгое взаимодействие между сервисами.
- **Мультиязычная поддержка:** Работает с множеством языков программирования, что упрощает создание микросервисов, написанных на разных технологиях.

### **Минусы gRPC**

- **Ограниченная поддержка браузером:** Для использования в браузере требуется дополнительный слой (например, gRPC-Web) и прокси, в то время как REST имеет встроенную поддержку в любом браузере.
- **Сложность внедрения:** Настройка и интеграция gRPC могут быть более трудоёмкими по сравнению с REST.
- **Сложность для внешних потребителей:** Из-за своей закрытой и бинарной природы gRPC менее удобен для внешних клиентов и сторонних разработчиков.

![image.png](image%20371.png)

### SOAP

SOAP — это протокол для обмена структурированными сообщениями, чаще всего в формате XML, который подходит для сложных корпоративных интеграций, где важна безопасность и надежность. REST — это архитектурный стиль, более гибкий и простой, использующий стандартные HTTP-методы и поддерживающий разные форматы данных (в основном JSON). Основное отличие: **SOAP — это строгий протокол, а REST — гибкий архитектурный подход**. 

### **Плюсы и минусы SOAP**

**Плюсы:**

- **Безопасность:** Имеет встроенные механизмы безопасности, такие как WS-Security.
- **Надежность:** Обеспечивает надежную доставку сообщений с помощью встроенных механизмов.
- **Сложные транзакции:** Отлично подходит для сложных корпоративных систем, где важна строгая типизация данных и гарантии транзакций.
- **Поддержка разных протоколов:** Может работать через различные транспортные протоколы, такие как HTTP, SMTP и другие.

**Минусы:**

- **Сложность:** Более сложен в разработке, отладке и тестировании по сравнению с REST.
- **Производительность:** Менее эффективен для обмена небольшими объемами данных из-за более громоздкого формата XML и дополнительных заголовков.
- **Формат:** Требует строгого использования формата XML, что ограничивает гибкость.

### Пример xml-сообщения

![image.png](image%20372.png)

**Когда используется SOAP**

- **Безопасность и надежность:** Когда необходимо обеспечить высокий уровень безопасности (например, через WS-Security) и гарантировать доставку сообщений, как в банковских операциях или госуслугах.
- **Корпоративная интеграция:** Для связи сложных внутренних систем (учет, финансы), когда важна строгая структура обмена данными.
- **Интеграция с существующими системами:** Когда нужно подключиться к старым или корпоративным приложениям, которые уже используют SOAP.
- **Асинхронная обработка и операции с состоянием:** Когда требуется поддержка транзакций или когда состояние должно сохраняться между запросами.
- **Строгие стандарты:** Когда существует соглашение о формальном и стандартизированном формате обмена данными, например, в онлайн-покупках.