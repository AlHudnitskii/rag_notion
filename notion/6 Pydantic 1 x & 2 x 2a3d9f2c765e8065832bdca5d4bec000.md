# 6. Pydantic 1.x & 2.x

Категория: Frameworks & Libraries
Статус: Готово

Интересный факт: более 30% всех Python-проектов используют Pydantic, даже если это не всегда заметно на первый взгляд. А такие фреймворки, как **FastAPI**, вообще строят свою логику на основе Pydantic, делая его неотъемлемой частью своих решений.

Pydantic 2 - это библиотека для Python, предназначенная для валидации и трансформации данных. Она помогает разработчикам гарантировать, что входные данные соответствуют установленным правилам и типах, а также обеспечивают из автоматическое преобразование в нужные форматы.

### **Основные функции Pydantic:**

- Валидация данных
- Трансформация данных

Модели в Pydantic наследуются от класса BaseModel. Каждая модель описывает набор полей, которые представляют собой структуру данных и условия для их валидации.

### **Описание полей:**

- **Типизация:** Поля в модели описываются с указанием типов, например, `name: str`. Это обеспечивает базовую типовую валидацию.
- **Использование** `Field()`: Позволяет аннотировать поля с дополнительными параметрами, такими как значения по умолчанию, ограничения и другие настройки.

![image.png](image%20430.png)

### **Валидация полей**

1. **Минимальная валидация типов:** Используя встроенные типы Python (например, `str`, `int`), можно проводить базовую проверку полей.
2. **Использование валидаторов:** В Pydantic доступны валидаторы, такие как `EmailStr` для проверки email-адресов. Для использования расширенных валидаторов требуется установка дополнительных зависимостей: `pydantic[email]` или `pydantic[all]`.

![image.png](image%20431.png)

Одна из новых возможностей 2 версии Pydantic - использование декораторов для кастомной логики валидации поля.

- `@field_validator` — заменяет старый `@validator` и позволяет добавлять кастомную логику валидации поля. Вызывается при создании или изменении модели.

![image.png](image%20432.png)

• `@computed_field` — поле, которое вычисляется на основе других данных в модели. Его можно использовать для автоматической генерации значений, а также для валидации.

![image.png](image%20433.png)

### Работа с ORM в Pydantic

Pydantic поддерживает интеграцию с ORM (например, **SQLAlchemy**) для валидации и трансформации данных, полученных из базы данных.

- Чтобы настроить модель для работы с ORM, используйте параметр `ConfigDict` с флагом `from_attributes=True`.

(В первой версии библиотеки используется class Config)
1. Для создания модели Pydantic из объекта ORM используется метод `from_orm`.

![image.png](image%20434.png)

1. `dict()` / `model_dump()` — преобразуют модель в словарь Python. В версии 2 метод `model_dump()` стал аналогом `dict()`.

![image.png](image%20435.png)

1. `json()` / `model_dump_json()` — преобразуют модель в JSON-строку. В новой версии метод `model_dump_json()` заменяет старый `json()`.

![image.png](image%20436.png)

Для передачи данных в модель используется: 

1. Банальное использование именованных аргументов напрямую при создании экземпляра

![image.png](image%20437.png)

1. Распакованные словари (используется **)

![image.png](image%20438.png)

### Автоматическое преобразование типов в Pydantic

Pydantic выполняет валидацию данных, а также может автоматически преобразовывать типы в некоторых случаях. Однако такие преобразования происходят только для данных, которые можно безопасно и однозначно привести к ожидаемому типу. 

Работает

![image.png](image%20439.png)

Вылетает ошибка

![image.png](image%20440.png)

**Выходов из этой ситуации два:**

1. Стараться передавать корректные данные для неоднозначных случаев
2. Использовать валидаторы полей, которые будут выполнять трансформацию данных внутри модели до основной проверки типов и преобразовать в строку. (Использование декоратора field_validator)

Декоратор `field_validator` служит для проверки корректности заполнения полей модели Pydantic. Помимо валидации, его можно использовать для преобразования данных перед их сохранением в модели.

![image.png](image%20441.png)

Декоратор `field_validator`  всегда принимает один обязательный элемент - название поля, которое и нужно валидировать.  Второй параметр - mode. Используется для указание момента валидации - до `mode='before'`.
 и после создания экземпляра  `mode='after'`.

Добавив проверку валидации можно получить более чистый валидатор:

![image.png](image%20442.png)

В старых версиях Pydantic этот декоратор назывался `root_validator`. Его основное назначение — валидация модели **в целом**, после того как все поля уже прошли индивидуальную проверку. Это позволяет выполнять комплексные проверки, зависящие от нескольких полей модели одновременно.

### **Основные особенности декоратора @model_validator:**

- Выполняется после валидации отдельных полей.
- Имеет доступ ко всем полям модели одновременно.
- Может изменять значения полей или всю модель целиком.
- Используется для сложных проверок, связанных с несколькими полями.

Для нашего поля напишем @model_validator**:**

![image.png](image%20443.png)

В этом примере:

- Метод `check_age` проверяет, что возраст пользователя больше 18 лет, но меньше 120 лет. Эта проверка требует доступа к полю `birthday_date` и текущей дате, поэтому она реализована как валидатор модели.
- Метод `set_default_name` устанавливает имя по умолчанию, если поле `name` пустое. Этот валидатор использует несколько полей (имя и идентификатор), поэтому также реализован на уровне модели.

Вычисляемые поля (computed_field)

Декоратор `@computed_field`  позволяет создавать поля, которые вычисляются “на лету” при доступе к ним. Это полезно, когда нужно автоматически получать значения, основанные на других полях модели.

![image.png](image%20444.png)

- Поле `full_name` вычисляется через объединение имени и фамилии.
- Поле `age` рассчитывает возраст пользователя в годах, месяцах и днях с использованием библиотеки модуля`relativedelta` библиотеки `dateutil`.

Декораторы `@model_validator`, `@field_validator` и `@computed_field` позволяют гибко и эффективно управлять валидацией данных в моделях Pydantic, а также добавлять вычисляемые поля. Валидация на уровне модели полезна для комплексных проверок, в то время как вычисляемые поля облегчают работу с производными значениями, не требуя дополнительной логики в коде.

### **Аннотируемые поля в Pydantic 2: использование функции Field**

Pydantic 2 предлагает разработчикам удобный и мощный способ работы с полями моделей данных, и одним из ключевых инструментов для этого является функция `Field`. Она позволяет детализировать поведение полей: задавать значения по умолчанию, добавлять метаданные, настраивать валидацию и даже документировать модель.
Функция `Field` позволяет добавлять к полям моделей метаданные и настройки, которые Pydantic использует для валидации, сериализации и документирования. Вот основные параметры, которые можно передавать в `Field`:

- `default`: устанавливает значение по умолчанию для поля.
- `default_factory`: функция, возвращающая значение по умолчанию.

![image.png](image%20445.png)

- `alias`: альтернативное имя поля для сериализации и десериализации.

![image.png](image%20446.png)

При задании **алиас** для поля, это поле будет иметь одно имя в вашем Python-коде, но при отправке данных в формате JSON или чтении из него оно будет использовать другое имя, указанное в качестве алиаса.

- `title`: заголовок поля для документации.
- `description`: описание поля для документации.
- `exclude`: исключает поле из сериализации.

![image.png](image%20447.png)

В данном примере поле password будет исключено из сериализованного представления объекта модели.

Это значит, что при сериализации объекта модели (например, при преобразовании его в JSON или словарь), поле `password` не будет включено в результат. Таким образом, вы можете скрыть конфиденциальную информацию, такую как пароли, от внешних систем или клиентов.

- `repr`: определяет, будет ли поле включено в строковое представление модели.

![image.png](image%20448.png)

Можно контролировать, какие поля будут отображаться в строковом представлении модели, используя параметр `repr`. Параметр `repr=False` позволяет исключить определённые поля из этого представления, чтобы они не отображались при выводе объекта, даже если они присутствуют в модели.
Строковое представление объекта модели — это то, что возвращается при вызове `repr()` или `str()` .

Функция `Field` также позволяет задавать различные **ограничения для значений**. Например, можно определить минимальные и максимальные значения для числовых полей, или ограничить длину строк.
Примеры встроенных валидаторов в `Field` для числовых типов: 

- `gt` (greater than): Проверяет, что значение больше указанного числа.
- `ge` (greater than or equal): Проверяет, что значение больше или равно указанному числу.
- `lt` (less than): Проверяет, что значение меньше указанного числа.
- `le` (less than or equal): Проверяет, что значение меньше или равно указанному числу.

Примеры встроенных валидаторов в`Field`для строковых данных:

- `min_length`: Задаёт минимальное количество символов, которое должно быть в строке.
- `max_length`: Задаёт максимальное количество символов, которое может содержать строка.
- `regex`: Задаёт регулярное выражение, которому должна соответствовать строка.Пример: `Field(regex=r"[^@]+@[^@]+\.[^@]+")` — проверка, что строка является корректным email-адресом.

### Расширенные возможности Annotated

Annotated - способ добавить метаданные и валидацию более гибко и тонко.

![image.png](image%20449.png)

### Конфигурация моделей в Pydantic 2

В Pydantic 2 конфигурация моделей теперь задаётся через **ConfigDict**, а не через старый формат с классом `Config`. Это важное изменение, которое упрощает настройку и делает её более гибкой.
В Pydantic 1:

![image.png](image%20450.png)

В Pydantic 2;

![image.png](image%20451.png)

Основные опции ConfigDict: 

- `from_attributes=True` — позволяет создавать объект модели напрямую из атрибутов Python-объектов (например, когда поля модели совпадают с атрибутами другого объекта). Чаще всего опция применяется для преобразования моделей ORM к моделям Pydantic.
- `str_to_lower, str_to_upper` - преобразование всех строк модели в нижний или верхний регистр
- `str_strip_whitespace` - cледует ли удалять начальные и конечные пробелы для типов str (аналог strip)
- `str_min_length, str_max_length` - задает максимальную и минимальную длину строки для всех строковых полей
- `use_enum_values` - cледует ли заполнять модели значениями, выбранными из перечислений, вместо того чтобы использовать необработанные значения? Это часто требуется при работе с моделями ORM, в которых колонки определены как перечисления (ENUM).

Это важно, потому что данные опции делают конфигурацию моделей более явной, удобной и гибкой. Использование ConfigDict позволяет определять параметры моделей напрямую через словарь, избегая необходимости создания вложенных классов, что упрощает процесс настройки и делает его более интуитивно понятным. Это особенно полезно при работе с большими и сложными моделями данных, где требуется высокая степень кастомизации.

### **Наследование в Pydantic 2**

Наследование в Pydantic позволяет создавать модели, которые могут переопределять или расширять атрибуты и методы своих родительских моделей. Это делает код более гибким и позволяет избежать дублирования.

![image.png](image%20452.png)

Преимущества:

- **Повторное использование кода**: общие поля и методы можно определить в базовой модели.
- **Расширяемость**: дочерние модели могут добавлять новые поля или методы.

### Связка Pydantic 2 c ORM

При работе с SQLAlchemy в ORM-стиле мы сталкиваемся с одним существенным неудобством: данные возвращаются в виде объектов моделей таблиц, что не всегда удобно для дальнейшей обработки. Разработчики обычно предпочитают работать с данными в формате JSON или Python-словарей. Именно здесь на помощь приходит Pydantic.

**Концепция обратной валидации**

Идея заключается в использовании Pydantic моделей не только для валидации выходных данных, но и для структурирования входных параметров запросов к базе данных. Это обеспечивает типобезопасность и удобство использования при формировании фильтров для запросов.

![image.png](image%20453.png)

### **Преимущества этого подхода**

1. **Типобезопасность**: Pydantic обеспечивает валидацию типов входных данных.
2. **Гибкость**: Легко создавать различные модели фильтров для разных запросов.
3. **Читаемость**: Код становится более понятным и структурированным.
4. **Переиспользование**: Модели фильтров можно использовать в разных частях приложения.

В Pydantic 2.0+ метод `model_validate` стал более гибким и удобным. Вы можете напрямую указать `from_attributes=True` при вызове метода:

![image.png](image%20454.png)

Это позволяет динамически контролировать, будут ли атрибуты объекта использоваться для создания модели, без необходимости изменения конфигурации самой модели.

Другие полезные атрибуты `model_validate`:

1. `strict`: bool | None
    - Когда установлен в `True`, применяет строгую валидацию типов.
    - Пример: `model_validate(data, strict=True)`
2. `context`: Any | None
    - Позволяет передать дополнительный контекст валидаторам.
    - Пример: `model_validate(data, context={'user_id': 123})`
3. `from_attributes`: bool | None
    - Как мы уже обсудили, позволяет извлекать данные из атрибутов объекта.

### Практическое применение Pydantic в различных областях

Pydantic — это мощный инструмент, который находит широкое применение в различных сферах разработки. Вот несколько ключевых областей, где Pydantic может быть особенно полезен:

- **1. Веб-разработка**

Pydantic часто используется в веб-фреймворках, таких как FastAPI и Flask, для валидации входящих данных от пользователей. Это позволяет разработчикам легко обрабатывать JSON-запросы и гарантировать, что данные соответствуют ожидаемым типам.

- **2. API и микросервисы**

При создании RESTful API Pydantic помогает определять схемы данных и автоматически генерировать документацию. Это упрощает интеграцию между различными сервисами и обеспечивает согласованность данных.

- **3. Обработка конфигураций**

Pydantic можно использовать для работы с конфигурационными файлами (например, JSON или YAML). Это позволяет легко загружать и валидировать настройки приложения, минимизируя вероятность ошибок.

- **4. Обработка данных**

В проектах, связанных с анализом данных или машинным обучением, Pydantic помогает валидировать входные данные и гарантировать, что они соответствуют необходимым требованиям перед их обработкой.

- **5. Тестирование**

Pydantic может быть полезен при написании тестов, позволяя создавать фиктивные данные с гарантией их корректности. Это упрощает процесс тестирования и повышает его надежность.

### Различия между Pydantic 1.x и Pydantic 2.x

### **Проблемы производительности 1.x**

Pydantic 1.x был полностью написан на Python, что создавало узкие места:

- **Медленная валидация** при больших объёмах данных
- **Высокое потребление CPU** на сложных моделях
- **Проблемы с масштабированием** в high-load приложениях

FastAPI (который активно использует Pydantic) рос в популярности, и производительность валидации становилась критичной для многих проектов.

**Решение - Rust-ядро:**

Авторы переписали критичную часть на Rust:

- **Валидация, сериализация и парсинг** — теперь на Rust
- API - остался на Python

Различия версий:

1. Философия валидации

**Pydantic 1.x — "Lax mode" (мягкий режим) -** *1.x пытается преобразовать всё что можно*

**Pydantic 2.x — Гибкие режимы (использование strict в ConfigDict)**

1. API изменения 

![image.png](image%20455.png)

![image.png](image%20456.png)

![image.png](image%20457.png)

1. Изменения валидаторов

1.x — три типа валидаторов:

- *Валидатор поля (до преобразования типа)*

@validator('discount', pre=True)

- *Валидатор поля (после преобразования)*

@validator('price')

- *Валидатор всей модели*

@root_validator

2.x - новые декораторы:

- *Валидатор поля (mode='before' или 'after')*

@field_validator('price')

P.S. *Можно валидировать несколько полей*

@field_validator('price', 'discount')

- *Валидатор модели (mode='before', 'after')*

@model_validator(mode='after')

1. Работа с типами - Annnotated в 2.x
2. Кастомная сериализация в 2.x 

![image.png](image%20458.png)

1. Computed Fields в 2.x 

![image.png](image%20459.png)

Версии 1.x и 2.x несовместимы.

## Settings management

Pydantic Settings снабжает Pydantic функциями для загрузки настроек или класса конфигураций из переменных среды.

![image.png](image%20460.png)

Пример использования

![image.png](image%20461.png)

Для чтения настроек из .env-файла необходимо использовать SettingsConfigDict:

![image.png](image%20462.png)

Для создания Settings один раз нужно воспользоваться декоратором lru_cache из модуля functools:

![image.png](image%20463.png)