# 1. Async

Категория: Python Async & Related
Статус: В процессе

**Асинхронность** — это способ выполнения кода, при котором программа может переключаться между задачами, не дожидаясь завершения каждой из них.

P.S. (Асинхронность написана на генераторах)

**Эволюция:**

Генераторы (yield) → Корутины (yield from) → Современные корутины (async/await)
Ключевые концепции асинхронности:

1. Event Loop (Цикл событий) - управляет выполнением асинхронных задач. Он переключается между задачами, когда они ждут I/O.

В Python работает принцип “один event loop на один поток”. 

1. Coroutune (Сопрограмма/Корутина) - асинхронная функция.

![image.png](image%20281.png)

1. Task (Задача) - обертка вокруг корутины для выполнения. 

![image.png](image%20282.png)

1. await - точка переключения контекста

![image.png](image%20283.png)

### Для чего вообще нужен asyncio?

1. I/O-bound задачи

Asyncio идеален для:

- HTTP запросы (веб-скрейпинг, API вызовы)
- Работа с базами данных
- Чтение/запись файлов
- WebSocket соединения
- Сетевые операции

Пример 

![image.png](image%20284.png)

1. Высокая конкурентность (Concurrency) 

Asyncio может обрабатывать тысячи соединений в одном потоке! FastAPI/aiohttp могут обслуживать 10000+ req/sec на одном процессе (цифры неточные, но точно много).

1. Эффективное использование ресурсов 

Один поток, но высокая производительность для I/O. Нет overhead на создание потоков/процессов. Меньше потребление памяти.

### Основы asyncio

1. Определение корутин происходит с помощью async def.
2. Запуск корутин:
- asyncio.run()

![image.png](image%20285.png)

- get_event_loop()

![image.png](image%20286.png)

1. await - точка переключения 

**Важно:** await можно использовать только:

- С корутинами (async def)
- С awaitable объектами (Tasks, Futures)
- Внутри async функций

### Параллельное выполнение корутин

1. asyncio.create_task() - Корутина запускается немедленно

![image.png](image%20287.png)

1. asyncio.gather() — запуск нескольких корутин

Для сбора ошибок нужно в параметрах gather прописать return_exceptions=True

![image.png](image%20288.png)

Функция gather гарантирует детерминированный порядок результатов, несмотря на
недетерминированность их получения. На внутреннем уровне gather использует для этой цели специальную реализацию future.

1. asyncio.wait() — больше контроля

![image.png](image%20289.png)

1.  asyncio.wait_for() — таймаут для одной задачи

![image.png](image%20290.png)

![image.png](image%20291.png)

5. asyncio.as_completed() — обработка по мере завершения

![image.png](image%20292.png)

### Работа с Event Loop

Получение event loop:

1. asyncio.get_running_loop()

![image.png](image%20293.png)

![image.png](image%20294.png)

1. asyncio.get_event_loop() - устаревший 

![image.png](image%20295.png)

Существует еще функция asyncio.get_event_loop, также позволяющая получить доступ к циклу событий. Эта функция может создать новый цикл событий, если его еще не существует в момент вызова, что ведет к  странному поведению. Рекомендуется использовать get_running_
loop, поскольку она возбуждает исключение, если цикл событий не запущен, что позволяет избежать сюрпризов.

### Callback

Планирование callback-ов. Коллбэк (callback) — это **функция, которая передаётся в качестве аргумента другой функции и вызывается ею после завершения какой-либо операции**. 

В асинхронности коллбэки используются для обработки результата асинхронного действия, например, загрузки данных или таймера, потому что функция-исполнитель не блокирует главный поток, а вызывает коллбэк по завершении работы. Это позволяет выполнять код параллельно и избегать блокировки программы. 

![image.png](image%20296.png)

### Синхронизация в asyncio

1. asyncio.Lock, которым можно управлять руками 

![image.png](image%20297.png)

1. asyncio.Semaphore — ограничение конкурентности

![image.png](image%20298.png)

3. asyncio.Event — сигнализация между корутинами

![image.png](image%20299.png)

![image.png](image%20300.png)

1. asyncio.Queue — асинхронная очередь

![image.png](image%20301.png)

![image.png](image%20302.png)

### Async Iterators и Async Generators

Асинхронный итератор 

![image.png](image%20303.png)

**Асинхронный генератор** 

Для синхронных методов все это работает, но как быть, если мы хотим использовать сопрограммы для асинхронного порождения последовательности значений? В  нашем примере с  базой данных как можно «лениво» получить данные из базы?

 Для этого в Python имеются асинхронные генераторы и специальная конструкция async for.

![image.png](image%20304.png)

Как видим, это не обычный генератор, а объект типа <class 'async_generator'>. Асинхронный генератор отличается от обычного тем, что отдает не объекты Python, а  генерирует сопрограммы, которые могут ждать получения результата с помощью await. Поэтому обычные циклы for и функция next с такими генераторами работать не будут.
А вместо них предложена специальная синтаксическая конструкция async for.

### Futeres

**Futures** в асинхронности - это объекты, которые представляют **результат асинхронной операции, который может быть еще не готов**. Это способ работать с асинхронными задачами в более удобном и предсказуемом формате.

Future - это "обещание" (promise) того, что в будущем у нас будет результат операции.

![image.png](image%20305.png)

Для создания объекта future нужно вызвать его конструктор. В этот момент во future нет никакого результата, поэтому вызов метода done возвращает False. Затем мы устанавливаем значение future методом set_result, который помечает его как готовый. Если бы вместо
этого мы хотели записать во future исключение, то вызвали бы метод set_exception.

![image.png](image%20306.png)

### Asyncio.shield

Данная функция предотвращает снятие сопрограммы, снабжая ее “щитом”, позволяющим игнорировать запросы на снятие. 

![image.png](image%20307.png)

Здесь мы сначала создаем задачу, обертывающую сопрограмму.
В этом состоит отличие от нашего первого примера снятия, потому
что нам необходим доступ к задаче в блоке except. Если бы мы передали сопрограмму, то wait_for обернула бы ее задачей, но сослаться
на эту задачу мы бы не смогли, потому что она внутренняя.
Затем внутри блока try мы вызываем wait_for, обернув предварительно задачу функцией shield, чтобы она не была снята. В блоке
обработки исключения мы печатаем полезное сообщение пользователю, в котором говорим, что задача еще работает, после чего ждем
ее завершения с помощью await. Это позволит задаче доработать до
конца, а пользователь увидит следующие сообщения:

![image.png](image%20308.png)

Снятие и защита от снятия – довольно хитрые вещи, у которых есть
несколько достойных внимания сценариев применения.

### time.sleep() and asyncio.sleep()

**Обычный `sleep()` блокирует весь процесс:**

![image.png](image%20309.png)

**`time.sleep()` - БЛОКИРУЮЩИЙ**

![image.png](image%20310.png)

**`asyncio.sleep()` - НЕБЛОКИРУЮЩИЙ**

asyncio.sleep сама является сопрограммой, поэтому вызывать ее
следует с помощью await.

![image.png](image%20311.png)

![image.png](image%20312.png)