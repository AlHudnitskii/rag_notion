# 10. Indexes

Категория: SQL Databases
Статус: Готово

Индексы создаются автоматически и в ручном режиме, а поддерживаются только автоматически. Индексы нужны для более быстрого чтения данных с БД.

![image.png](image%20544.png)

P.S. Создание индекса для большой таблицы может занимать много времени. По умолчанию PostgreSQL позволяет параллельно с созданием индекса выполнять чтение (операторы `SELECT`) таблицы, но операции записи (`INSERT`, `UPDATE` и `DELETE`) блокируются до окончания построения индекса. Для производственной среды это ограничение часто бывает неприемлемым.
Когда индекс создавать стоит:

- Когда в колонке много значений NULL
- Когда колонка используется во WHERE или в JOIN
- Запросами извлекается до 4% значений

Когда индексы использовать не стоит:

- Когда значения таблицы часто обновляются
- Когда в таблицы мало значений

### Кластеризированные и некластеризированные индексы

Кластеризованный индекс физически упорядочивает строки таблицы по значениям индекса, тогда как некластеризованный индекс хранит отдельную структуру с указателями на данные. Основное различие в том, что кластеризованный индекс определяет **физический порядок хранения** записей, а некластеризованный — это вспомогательный объект, который **только ссылается** на данные. 

PostgreSQL поддерживает несколько типов индексов: B-дерево, хеш, GiST, SP-GiST, GIN и BRIN.

### B-tree index

Планировщик запросов PostgreSQL может задействовать индекс-B-дерево, когда индексируемый столбец участвует в сравнении с одним из следующих операторов:

![image.png](image%20545.png)

При обработке конструкций, представимых как сочетание этих операторов, например `BETWEEN` и `IN`, так же может выполняться поиск по индексу-B-дереву. Кроме того, такие индексы могут использоваться и в условиях `IS NULL` и `IS NOT NULL` по индексированным столбцам.

### Hash index

Хеш-индексы хранят 32-битный хеш-код, полученный из значения индексированного столбца, поэтому хеш-индексы работают только с простыми условиями равенства. Планировщик запросов может применить хеш-индекс, только если индексируемый столбец участвует в сравнении с оператором `=`. Создать такой индекс можно следующей командой:

![image.png](image%20546.png)

### GIST index

GiST — сокращение от «generalized search tree». Это сбалансированное дерево поиска, точно так же, как и рассмотренный ранее b-tree.
В чем же разница? Индекс b-tree жестко привязан к семантике сравнения: поддержка операторов «больше», «меньше», «равно» — это все, на что он способен (зато способен очень хорошо!). Но в современных базах хранятся и такие типы данных, для которых эти операторы просто не имеют смысла: геоданные, текстовые документы, картинки… 
Тут на помощь и приходит индексный метод GiST. Он позволяет задать принцип
распределения данных произвольного типа по сбалансированному дереву, и метод
использования этого представления для доступа по некоторому оператору. Например,
в GiST-индекс можно «уложить» R-дерево для пространственных данных с
поддержкой операторов взаимного расположения (находится слева, справа;
содержит и т. п.), или RD-дерево для множеств с поддержкой операторов
пересечения или вхождения. Разбивается на прямоугольнички (как отдельные
странички индексов и по ним поиск осуществляется очень быстро).

GiST-индексы также могут оптимизировать поиск «ближайшего соседа», например такой:

![image.png](image%20547.png)

который возвращает десять расположений, ближайших к заданной точке.

### SP-GiST index

В sp-gist легче засовывать данные, поэтому там где данные меняются часто лучше
использовать его, а вот что касается GIST, если туда часто сувать данные, то
система будет деградировать и эффективность сведеться к 0). 

«SP» расшифровывается как space partitioning, разбиение пространства. В роли
пространства часто выступает именно то, что мы и привыкли называть
пространством — например, двумерная плоскость. 

Но, как мы увидим, имеется в виду любое пространство поиска, по сути произвольная область значений. 
SP-GiST подходит для структур, в которых пространство рекурсивно разбивается на
непересекающиеся области. В этот класс входят деревья квадрантов (quadtree), kмерные деревья (k-D tree), префиксные деревья (trie).

SP-GiST позволяет организовывать на диске самые разные несбалансированные структуры данных, такие как деревья квадрантов, k-мерные и префиксные деревья. Например, стандартный дистрибутив PostgreSQL включает классы операторов SP-GiST для точек в двумерном пространстве, что позволяет применять индексы в запросах с операторами:

![image.png](image%20548.png)

P.S. Для классов операторов SP-GiST, поддерживающих упорядочивание по расстоянию

### GIN index “Generalized Inverted Index”

GIN-индексы представляют собой «инвертированные индексы», в которых могут содержаться значения с несколькими ключами, например массивы. Инвертированный индекс содержит отдельный элемент для значения каждого компонента, и может эффективно работать в запросах, проверяющих присутствие определённых значений компонентов.

### BRIN index

BRIN-индексы (сокращение от Block Range INdexes, Индексы зон блоков) хранят обобщённые сведения о значениях, находящихся в физически последовательно расположенных блоках таблицы. Поэтому такие индексы наиболее эффективны для столбцов, значения в которых хорошо коррелируют с физическим порядком столбцов таблицы.

Для типов данных, имеющих линейный порядок сортировки, записям в индексе соответствуют минимальные и максимальные значения данных в столбце для каждой зоны блоков. Это позволяет поддерживать запросы со следующими операторами:

![image.png](image%20549.png)

### Составные индексы и объединение индексов

Индексы также можно указывать и по нескольким столбцам:

![image.png](image%20550.png)

В настоящее время составными могут быть только индексы типов B-дерево, GiST, GIN и BRIN. Возможность построения индекса по нескольким ключевым столбцам не зависит от возможности добавления в индекс неключевых столбцов (`INCLUDE`). Число столбцов в индексе ограничивается 32, включая столбцы `INCLUDE`.

Выполняя объединение нескольких индексов, система сканирует все необходимые индексы и создаёт в памяти *битовую карту* расположения строк таблицы, которые удовлетворяют условиям каждого индекса. Затем битовые карты объединяются операциями AND и OR, как того требуют условия в запросе. Наконец система обращается к соответствующим отмеченным строкам таблицы и возвращает их данные. Строки таблицы просматриваются в физическом порядке, как они представлены в битовой карте; это означает, что порядок сортировки индексов при этом теряется и в запросах с предложением `ORDER BY` сортировка будет выполняться отдельно. По этой причине, а также потому, что каждое сканирование индекса занимает дополнительное время, планировщик иногда выбирает простое сканирование индекса, несмотря на то, что можно было бы подключить и дополнительные индексы.

### Частичный индекс

*Частичный индекс* — это индекс, который строится по подмножеству строк таблицы, определяемому условным выражением (оно называется *предикатом* частичного индекса). Такой индекс содержит записи только для строк, удовлетворяющих предикату. Частичные индексы довольно специфичны, но в ряде ситуаций они могут быть очень полезны. Пример создания такого индекса ниже:

![image.png](image%20551.png)

### Просмотр покрытия индексами

![image.png](image%20552.png)