# 1. Django/DRF

Категория: Frameworks & Libraries
Статус: В процессе

## Django

Django — это высокоуровневый Python веб-фреймворк, который позволяет быстро создавать безопасные и поддерживаемые веб-сайты.

Django следует философии «Всё включено» и предоставляет почти всё, что разработчики могут захотеть сделать «из коробки».

### Как выглядит код Django?

На традиционном информационном сайте веб-приложение ожидает HTTP-запросы от веб-браузера (или другого клиента). Когда запрос получен, приложение разрабатывает то, что необходимо на основе URL-адреса и, возможно, данных в `POST` или `GET` запросах. В зависимости от того, что требуется, далее он может читать или записывать информацию из базы данных или выполнять другие задачи, необходимые для удовлетворения запроса. Затем приложение вернёт ответ веб-браузеру, часто динамически создавая HTML-страницу для отображения в браузере, вставляя полученные данные в HTML-шаблон.
Веб-приложения, написанные на Django, обычно группируют код, который обрабатывает каждый из этих шагов, в отдельные файлы:

![image.png](image%20210.png)

- **URLs:** URL-маршрутизатор используется для перенаправления HTTP-запросов в соответствующее представление на основе URL-адреса запроса.
- **View:** View  — это функция обработчика запросов, которая получает HTTP-запросы и возвращает ответы. Функция view имеет доступ к данным, необходимым для удовлетворения запросов, и делегирует ответы в шаблоны через модели.
- **Models:** Модели представляют собой объекты Python, которые определяют структуру данных приложения и предоставляют механизмы для управления (добавления, изменения, удаления) и выполнения запросов в базу данных.
- **Templates:** Template — это текстовый файл, определяющий структуру или разметку страницы, с полями для подстановки, которые используются для вывода актуального содержимого.

## **Signals в Django**

Signals - встроенный механизм в Django, который позволяет разным частям приложения “общаться” друг с другом через события.

Зачем они нужны:

- Нужно реагировать на определённые действия в приложении (например, сохранение объекта или завершение запроса).
- Нужно изолировать логику обработки событий, чтобы основной код оставался чистым.
- Не хотите вмешиваться в сторонние приложения, но хотите знать, когда там что‑то происходит.

Как это работает:

1. **Отправитель (Sender):** генерирует событие.
2. **Сигнал (Signal):** уведомляет зарегистрированные обработчики.
3. **Обработчики (Receivers):** реагируют на сигнал, выполняя нужную логику.

Встроенные сигналы в Django:

- `pre_save` и `post_save` — до и после сохранения объекта.
- `pre_delete` и `post_delete` — до и после удаления объекта.
- `request_started` и `request_finished` — в начале и конце запроса.
- `user_logged_in`, `user_logged_out` — пользователь вошёл/вышел.

Для подключения обработчиков:

1. Метод `connect`

![image.png](image%20211.png)

1. Декоратор `@receiver`:

![image.png](image%20212.png)

Основные проблемы при использовании сигналов в Django включают дублирование обработчиков (решается через `dispatch_uid`), пропуск обязательных аргументов `sender` и `**kwargs` в функциях-получателях, а также неправильное управление их подключением (следует хранить в `signals.py` и подключать через `apps.py`). Кроме того, использование сигналов может привести к избыточности, поэтому их следует применять только для изоляции логики, а не для каждой мелкой задачи. 

## Django channels

Django Channels — это **расширение для Django, которое позволяет обрабатывать протоколы, отличные от HTTP, такие как WebSockets, чаты и протоколы интернета вещей (IoT), а не только традиционные HTTP-запросы**. Оно основано на спецификации Python **ASGI** (Asynchronous Server Gateway Interface) и расширяет возможности Django для создания более интерактивных и асинхронных веб-приложений.

**Ключевые особенности**

- **Расширение за пределы HTTP:** Channels позволяют обрабатывать соединения, которые поддерживают постоянное двустороннее соединение между клиентом и сервером, в отличие от классической модели "запрос-ответ" HTTP.
- **Реализация ASGI:** Channels построен на базе ASGI, асинхронного стандарта, который дополняет синхронный WSGI. Это позволяет обрабатывать соединения асинхронно.
- **Работа с Django:** Channels не заменяет Django, а дополняет его. Он позволяет использовать Django для обработки синхронного HTTP-трафика, в то время как асинхронные протоколы обрабатываются с помощью Channels.
- **Группы каналов:** Позволяют отправлять сообщения всем соединениям в определенной "группе" (например, всем пользователям в чате), что удобно для реального времени.
- **Каналы:** Это "почтовые ящики" для отправки сообщений, которым присваиваются уникальные имена.
- **Слои каналов:** Обеспечивают связь между различными экземплярами приложения, что полезно для создания распределенных систем реального времени без необходимости использовать базу данных для каждого сообщения.

## DRF

Django Rest Framework — это библиотека, которая работает со стандартными моделями Django для создания гибкого и мощного API для проекта. 

API DRF состоит из 3-х слоев: 

- **Сериализатор**: преобразует информацию, хранящуюся в базе данных и определенную с помощью моделей Django, в формат, который легко и эффективно передается через API.
- **Вид (ViewSet)**: определяет функции (чтение, создание, обновление, удаление), которые будут доступны через API.
- **Маршрутизатор**: определяет URL-адреса, которые будут предоставлять доступ к каждому виду.

### Сериализаторы

Модели Django интуитивно представляют данные, хранящиеся в базе, но API должен передавать информацию в менее сложной структуре. Хотя данные будут представлены как экземпляры классов Model, их необходимо перевести в формат JSON для передачи через API. Для этого и нужны сериализаторы.

Настройки fields позволяют точно указать, какие поля доступны этому сериализатору. В качестве альтернативы, может быть установлен exclude вместо fields, которое будет включать все поля модели, кроме тех, которые указаны в exclude.

![image.png](image%20213.png)

### **Виды (ViewSets)**

Класс **`ViewSet`** - это тип представления на основе класса, который не предоставляет никаких обработчиков методов, таких как **`.get()`** или **`.post()`** , а вместо этого предоставляет действия, такие как **`.list()`** и **`.create()`**.

![image.png](image%20214.png)

Если нужно, мы можем связать этот набор представлений в два отдельных представления, например, так:

![image.png](image%20215.png)

Действия ViewSets

![image.png](image%20216.png)

В DRF существует несколько типов ViewSet:

- **ViewSet** (как в вашем примере) - базовый класс, требует реализации всех методов
- **ModelViewSet** - предоставляет готовые реализации для всех действий с моделью
- **ReadOnlyModelViewSet** - предоставляет только операции чтения (list, retrieve)

### Дополнительные действия

Можно провести с помощью декоратора `@action`

![image.png](image%20217.png)

ViewSet значительно упрощает разработку REST API, обеспечивая чистую структуру и следуя принципам DRY (Don't Repeat Yourself).

### **Маршрутизаторы (роутеры)**

И наконец, маршрутизаторы: они предоставляют верхний уровень API. Чтобы избежать создания бесконечных URL-адресов вида: «списки», «детали» и «изменить», маршрутизаторы DRF объединяют все URL-адреса, необходимые для данного вида в одну строку для каждого ViewSet, например:

![image.png](image%20218.png)

## Как работает middleware?

“Middleware” - функция, которая выполняется с каждым запросом до его обработки какой-либо конкретной операцией пути. А также с каждым ответом перед его возвращением.

- Она принимает каждый поступающий **запрос**.
- Может что-то сделать с этим **запросом** или выполнить любой нужный код.
- Затем передает **запрос** для последующей обработки (какой-либо *операцией пути*).
- Получает **ответ** (от *операции пути*).
- Может что-то сделать с этим **ответом** или выполнить любой нужный код.
- И возвращает **ответ**.

Пример middleware на FastAPI, показан код, использующий `request` до передачи его какой-либо операции пути, а также после формирования `response`, до того, как вы его вернёте.

![image.png](image%20219.png)

### **Порядок выполнения нескольких middleware**

Когда вы добавляете несколько middleware каждое новое middleware оборачивает приложение, формируя стек. Последнее добавленное middleware — самое внешнее (*outermost*), а первое — самое внутреннее (*innermost*).

На пути обработки запроса сначала выполняется самое внешнее middleware.

На пути формирования ответа оно выполняется последним.

**Пример**

![image.png](image%20220.png)

Это приводит к следующему порядку выполнения:

- **Запрос**: MiddlewareB → MiddlewareA → маршрут
- **Ответ**: маршрут → MiddlewareA → MiddlewareB

Такое стековое поведение обеспечивает предсказуемый и управляемый порядок выполнения middleware.