# 7. Partitioning

Категория: NoSQL & General theory
Статус: Готово

Партиционирование – это метод разделения больших (исходя из количества записей, а не столбцов) таблиц на много маленьких. И желательно, чтобы это происходило прозрачным для приложения способом.

**Partitioning (партиционирование)** — это способ разделить большую таблицу или коллекцию на независимые части (partitions), чтобы:

- ускорить запросы
- оптимизировать хранение
- уменьшить объём индексов
- повысить масштабируемость
- изолировать горячие и холодные данные

### Стратегии партицонирования

### RANGE Partitioning (партиционирование по диапазону)

Пример:

![image.png](image%20598.png)

### Когда применять?

- Данные растут “по времени”
- Хранение логов
- Тайм-серии
- Архивация старых данных

Особенности:

- Идеально для временных данных
- Быстрые запросы по диапазону (index pruning)
- Неравномерное распределение данных
    
    (последняя партиция всегда самая “горячая”)
    
    → нагрузка концентрируется на одной партиции
    
- Нужно заранее продумать диапазоны

### HASH Partitioning (партиционирование по хешу)

Данные распределяются по партициям на основе **hash(key) % N**. Пример ниже создаст 4 равные партиции:

![image.png](image%20599.png)

### Когда применять?

- Когда нужна **равномерная нагрузка**
- Когда ключи распределены плохо (user_id, email)
- Когда диапазоны не подходят

Особенности:

- Очень равномерное распределение нагрузки

- Используется в масштабируемых NoSQL
- Нельзя эффективно делать запросы “по диапазону”
    
    (WHERE time > …)
    
- Партиции невозможно логически разделить для архивирования

### LIST Partitioning (партиционирование по списку значений)

Данные попадают в партицию, если значение поля входит в фиксированный список.

![image.png](image%20600.png)

### Когда применять?

- Логические категории:
    - страны
    - регионы
    - типы пользователей
    - статусы заказов

Особенности:

- Простая логика
- Легко управлять партициями
- Хорошо подходит, если данных мало, но они логически разделены
- Подходит только для дискретных категорий
- При большом количестве уникальных значений — неудобно

### Примеры

![image.png](image%20601.png)

![image.png](image%20602.png)

![image.png](image%20603.png)

### GLOBAL INDEXES

При обычном партиционировании **каждая партиция имеет свой индекс**

![image.png](image%20604.png)

Проблема:

- чтобы найти user_id = 150, БД должна проверить **все партиции**
- индекс не знает, в какой партиции хранится запись

Это называется **partition pruning**, и он возможен только если WHERE использует partition key.

Решение проблемы - глобальный индекс, который покрывает ВСЕ партиции сразу.

Он хранит:

![image.png](image%20605.png)

![image.png](image%20606.png)

### Prons of GI

1. Быстрые запросы по не-партиционным полям

Если партиционирование идёт по `created_at`, но фильтрация — по `user_id`, без глобального индекса нужно:

- искать в каждой партиции → O(N partitions)
- медленнее индекса по всей таблице
1. Поддержка уникальных ключей

### В локальных индексах:

`UNIQUE(user_id)` невозможно,

потому что БД не знает, в какой партиции ключ.

### В глобальных индексах:

уникальность обеспечивается на уровне всей таблицы.

### Cons of GI

1. Дорожают операции вставки (индекс большой)
2. Хуже масштабируется при большом потоке INSERT